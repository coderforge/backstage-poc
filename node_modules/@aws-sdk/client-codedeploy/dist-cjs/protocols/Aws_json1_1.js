"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.de_BatchGetApplicationsCommand = exports.de_BatchGetApplicationRevisionsCommand = exports.de_AddTagsToOnPremisesInstancesCommand = exports.se_UpdateDeploymentGroupCommand = exports.se_UpdateApplicationCommand = exports.se_UntagResourceCommand = exports.se_TagResourceCommand = exports.se_StopDeploymentCommand = exports.se_SkipWaitTimeForInstanceTerminationCommand = exports.se_RemoveTagsFromOnPremisesInstancesCommand = exports.se_RegisterOnPremisesInstanceCommand = exports.se_RegisterApplicationRevisionCommand = exports.se_PutLifecycleEventHookExecutionStatusCommand = exports.se_ListTagsForResourceCommand = exports.se_ListOnPremisesInstancesCommand = exports.se_ListGitHubAccountTokenNamesCommand = exports.se_ListDeploymentTargetsCommand = exports.se_ListDeploymentsCommand = exports.se_ListDeploymentInstancesCommand = exports.se_ListDeploymentGroupsCommand = exports.se_ListDeploymentConfigsCommand = exports.se_ListApplicationsCommand = exports.se_ListApplicationRevisionsCommand = exports.se_GetOnPremisesInstanceCommand = exports.se_GetDeploymentTargetCommand = exports.se_GetDeploymentInstanceCommand = exports.se_GetDeploymentGroupCommand = exports.se_GetDeploymentConfigCommand = exports.se_GetDeploymentCommand = exports.se_GetApplicationRevisionCommand = exports.se_GetApplicationCommand = exports.se_DeregisterOnPremisesInstanceCommand = exports.se_DeleteResourcesByExternalIdCommand = exports.se_DeleteGitHubAccountTokenCommand = exports.se_DeleteDeploymentGroupCommand = exports.se_DeleteDeploymentConfigCommand = exports.se_DeleteApplicationCommand = exports.se_CreateDeploymentGroupCommand = exports.se_CreateDeploymentConfigCommand = exports.se_CreateDeploymentCommand = exports.se_CreateApplicationCommand = exports.se_ContinueDeploymentCommand = exports.se_BatchGetOnPremisesInstancesCommand = exports.se_BatchGetDeploymentTargetsCommand = exports.se_BatchGetDeploymentsCommand = exports.se_BatchGetDeploymentInstancesCommand = exports.se_BatchGetDeploymentGroupsCommand = exports.se_BatchGetApplicationsCommand = exports.se_BatchGetApplicationRevisionsCommand = exports.se_AddTagsToOnPremisesInstancesCommand = void 0;
exports.de_UpdateDeploymentGroupCommand = exports.de_UpdateApplicationCommand = exports.de_UntagResourceCommand = exports.de_TagResourceCommand = exports.de_StopDeploymentCommand = exports.de_SkipWaitTimeForInstanceTerminationCommand = exports.de_RemoveTagsFromOnPremisesInstancesCommand = exports.de_RegisterOnPremisesInstanceCommand = exports.de_RegisterApplicationRevisionCommand = exports.de_PutLifecycleEventHookExecutionStatusCommand = exports.de_ListTagsForResourceCommand = exports.de_ListOnPremisesInstancesCommand = exports.de_ListGitHubAccountTokenNamesCommand = exports.de_ListDeploymentTargetsCommand = exports.de_ListDeploymentsCommand = exports.de_ListDeploymentInstancesCommand = exports.de_ListDeploymentGroupsCommand = exports.de_ListDeploymentConfigsCommand = exports.de_ListApplicationsCommand = exports.de_ListApplicationRevisionsCommand = exports.de_GetOnPremisesInstanceCommand = exports.de_GetDeploymentTargetCommand = exports.de_GetDeploymentInstanceCommand = exports.de_GetDeploymentGroupCommand = exports.de_GetDeploymentConfigCommand = exports.de_GetDeploymentCommand = exports.de_GetApplicationRevisionCommand = exports.de_GetApplicationCommand = exports.de_DeregisterOnPremisesInstanceCommand = exports.de_DeleteResourcesByExternalIdCommand = exports.de_DeleteGitHubAccountTokenCommand = exports.de_DeleteDeploymentGroupCommand = exports.de_DeleteDeploymentConfigCommand = exports.de_DeleteApplicationCommand = exports.de_CreateDeploymentGroupCommand = exports.de_CreateDeploymentConfigCommand = exports.de_CreateDeploymentCommand = exports.de_CreateApplicationCommand = exports.de_ContinueDeploymentCommand = exports.de_BatchGetOnPremisesInstancesCommand = exports.de_BatchGetDeploymentTargetsCommand = exports.de_BatchGetDeploymentsCommand = exports.de_BatchGetDeploymentInstancesCommand = exports.de_BatchGetDeploymentGroupsCommand = void 0;
const protocol_http_1 = require("@smithy/protocol-http");
const smithy_client_1 = require("@smithy/smithy-client");
const CodeDeployServiceException_1 = require("../models/CodeDeployServiceException");
const models_0_1 = require("../models/models_0");
const se_AddTagsToOnPremisesInstancesCommand = async (input, context) => {
    const headers = sharedHeaders("AddTagsToOnPremisesInstances");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_AddTagsToOnPremisesInstancesCommand = se_AddTagsToOnPremisesInstancesCommand;
const se_BatchGetApplicationRevisionsCommand = async (input, context) => {
    const headers = sharedHeaders("BatchGetApplicationRevisions");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_BatchGetApplicationRevisionsCommand = se_BatchGetApplicationRevisionsCommand;
const se_BatchGetApplicationsCommand = async (input, context) => {
    const headers = sharedHeaders("BatchGetApplications");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_BatchGetApplicationsCommand = se_BatchGetApplicationsCommand;
const se_BatchGetDeploymentGroupsCommand = async (input, context) => {
    const headers = sharedHeaders("BatchGetDeploymentGroups");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_BatchGetDeploymentGroupsCommand = se_BatchGetDeploymentGroupsCommand;
const se_BatchGetDeploymentInstancesCommand = async (input, context) => {
    const headers = sharedHeaders("BatchGetDeploymentInstances");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_BatchGetDeploymentInstancesCommand = se_BatchGetDeploymentInstancesCommand;
const se_BatchGetDeploymentsCommand = async (input, context) => {
    const headers = sharedHeaders("BatchGetDeployments");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_BatchGetDeploymentsCommand = se_BatchGetDeploymentsCommand;
const se_BatchGetDeploymentTargetsCommand = async (input, context) => {
    const headers = sharedHeaders("BatchGetDeploymentTargets");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_BatchGetDeploymentTargetsCommand = se_BatchGetDeploymentTargetsCommand;
const se_BatchGetOnPremisesInstancesCommand = async (input, context) => {
    const headers = sharedHeaders("BatchGetOnPremisesInstances");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_BatchGetOnPremisesInstancesCommand = se_BatchGetOnPremisesInstancesCommand;
const se_ContinueDeploymentCommand = async (input, context) => {
    const headers = sharedHeaders("ContinueDeployment");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ContinueDeploymentCommand = se_ContinueDeploymentCommand;
const se_CreateApplicationCommand = async (input, context) => {
    const headers = sharedHeaders("CreateApplication");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_CreateApplicationCommand = se_CreateApplicationCommand;
const se_CreateDeploymentCommand = async (input, context) => {
    const headers = sharedHeaders("CreateDeployment");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_CreateDeploymentCommand = se_CreateDeploymentCommand;
const se_CreateDeploymentConfigCommand = async (input, context) => {
    const headers = sharedHeaders("CreateDeploymentConfig");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_CreateDeploymentConfigCommand = se_CreateDeploymentConfigCommand;
const se_CreateDeploymentGroupCommand = async (input, context) => {
    const headers = sharedHeaders("CreateDeploymentGroup");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_CreateDeploymentGroupCommand = se_CreateDeploymentGroupCommand;
const se_DeleteApplicationCommand = async (input, context) => {
    const headers = sharedHeaders("DeleteApplication");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeleteApplicationCommand = se_DeleteApplicationCommand;
const se_DeleteDeploymentConfigCommand = async (input, context) => {
    const headers = sharedHeaders("DeleteDeploymentConfig");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeleteDeploymentConfigCommand = se_DeleteDeploymentConfigCommand;
const se_DeleteDeploymentGroupCommand = async (input, context) => {
    const headers = sharedHeaders("DeleteDeploymentGroup");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeleteDeploymentGroupCommand = se_DeleteDeploymentGroupCommand;
const se_DeleteGitHubAccountTokenCommand = async (input, context) => {
    const headers = sharedHeaders("DeleteGitHubAccountToken");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeleteGitHubAccountTokenCommand = se_DeleteGitHubAccountTokenCommand;
const se_DeleteResourcesByExternalIdCommand = async (input, context) => {
    const headers = sharedHeaders("DeleteResourcesByExternalId");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeleteResourcesByExternalIdCommand = se_DeleteResourcesByExternalIdCommand;
const se_DeregisterOnPremisesInstanceCommand = async (input, context) => {
    const headers = sharedHeaders("DeregisterOnPremisesInstance");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeregisterOnPremisesInstanceCommand = se_DeregisterOnPremisesInstanceCommand;
const se_GetApplicationCommand = async (input, context) => {
    const headers = sharedHeaders("GetApplication");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetApplicationCommand = se_GetApplicationCommand;
const se_GetApplicationRevisionCommand = async (input, context) => {
    const headers = sharedHeaders("GetApplicationRevision");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetApplicationRevisionCommand = se_GetApplicationRevisionCommand;
const se_GetDeploymentCommand = async (input, context) => {
    const headers = sharedHeaders("GetDeployment");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetDeploymentCommand = se_GetDeploymentCommand;
const se_GetDeploymentConfigCommand = async (input, context) => {
    const headers = sharedHeaders("GetDeploymentConfig");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetDeploymentConfigCommand = se_GetDeploymentConfigCommand;
const se_GetDeploymentGroupCommand = async (input, context) => {
    const headers = sharedHeaders("GetDeploymentGroup");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetDeploymentGroupCommand = se_GetDeploymentGroupCommand;
const se_GetDeploymentInstanceCommand = async (input, context) => {
    const headers = sharedHeaders("GetDeploymentInstance");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetDeploymentInstanceCommand = se_GetDeploymentInstanceCommand;
const se_GetDeploymentTargetCommand = async (input, context) => {
    const headers = sharedHeaders("GetDeploymentTarget");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetDeploymentTargetCommand = se_GetDeploymentTargetCommand;
const se_GetOnPremisesInstanceCommand = async (input, context) => {
    const headers = sharedHeaders("GetOnPremisesInstance");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetOnPremisesInstanceCommand = se_GetOnPremisesInstanceCommand;
const se_ListApplicationRevisionsCommand = async (input, context) => {
    const headers = sharedHeaders("ListApplicationRevisions");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListApplicationRevisionsCommand = se_ListApplicationRevisionsCommand;
const se_ListApplicationsCommand = async (input, context) => {
    const headers = sharedHeaders("ListApplications");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListApplicationsCommand = se_ListApplicationsCommand;
const se_ListDeploymentConfigsCommand = async (input, context) => {
    const headers = sharedHeaders("ListDeploymentConfigs");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListDeploymentConfigsCommand = se_ListDeploymentConfigsCommand;
const se_ListDeploymentGroupsCommand = async (input, context) => {
    const headers = sharedHeaders("ListDeploymentGroups");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListDeploymentGroupsCommand = se_ListDeploymentGroupsCommand;
const se_ListDeploymentInstancesCommand = async (input, context) => {
    const headers = sharedHeaders("ListDeploymentInstances");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListDeploymentInstancesCommand = se_ListDeploymentInstancesCommand;
const se_ListDeploymentsCommand = async (input, context) => {
    const headers = sharedHeaders("ListDeployments");
    let body;
    body = JSON.stringify(se_ListDeploymentsInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListDeploymentsCommand = se_ListDeploymentsCommand;
const se_ListDeploymentTargetsCommand = async (input, context) => {
    const headers = sharedHeaders("ListDeploymentTargets");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListDeploymentTargetsCommand = se_ListDeploymentTargetsCommand;
const se_ListGitHubAccountTokenNamesCommand = async (input, context) => {
    const headers = sharedHeaders("ListGitHubAccountTokenNames");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListGitHubAccountTokenNamesCommand = se_ListGitHubAccountTokenNamesCommand;
const se_ListOnPremisesInstancesCommand = async (input, context) => {
    const headers = sharedHeaders("ListOnPremisesInstances");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListOnPremisesInstancesCommand = se_ListOnPremisesInstancesCommand;
const se_ListTagsForResourceCommand = async (input, context) => {
    const headers = sharedHeaders("ListTagsForResource");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListTagsForResourceCommand = se_ListTagsForResourceCommand;
const se_PutLifecycleEventHookExecutionStatusCommand = async (input, context) => {
    const headers = sharedHeaders("PutLifecycleEventHookExecutionStatus");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_PutLifecycleEventHookExecutionStatusCommand = se_PutLifecycleEventHookExecutionStatusCommand;
const se_RegisterApplicationRevisionCommand = async (input, context) => {
    const headers = sharedHeaders("RegisterApplicationRevision");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_RegisterApplicationRevisionCommand = se_RegisterApplicationRevisionCommand;
const se_RegisterOnPremisesInstanceCommand = async (input, context) => {
    const headers = sharedHeaders("RegisterOnPremisesInstance");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_RegisterOnPremisesInstanceCommand = se_RegisterOnPremisesInstanceCommand;
const se_RemoveTagsFromOnPremisesInstancesCommand = async (input, context) => {
    const headers = sharedHeaders("RemoveTagsFromOnPremisesInstances");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_RemoveTagsFromOnPremisesInstancesCommand = se_RemoveTagsFromOnPremisesInstancesCommand;
const se_SkipWaitTimeForInstanceTerminationCommand = async (input, context) => {
    const headers = sharedHeaders("SkipWaitTimeForInstanceTermination");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_SkipWaitTimeForInstanceTerminationCommand = se_SkipWaitTimeForInstanceTerminationCommand;
const se_StopDeploymentCommand = async (input, context) => {
    const headers = sharedHeaders("StopDeployment");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_StopDeploymentCommand = se_StopDeploymentCommand;
const se_TagResourceCommand = async (input, context) => {
    const headers = sharedHeaders("TagResource");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_TagResourceCommand = se_TagResourceCommand;
const se_UntagResourceCommand = async (input, context) => {
    const headers = sharedHeaders("UntagResource");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UntagResourceCommand = se_UntagResourceCommand;
const se_UpdateApplicationCommand = async (input, context) => {
    const headers = sharedHeaders("UpdateApplication");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UpdateApplicationCommand = se_UpdateApplicationCommand;
const se_UpdateDeploymentGroupCommand = async (input, context) => {
    const headers = sharedHeaders("UpdateDeploymentGroup");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UpdateDeploymentGroupCommand = se_UpdateDeploymentGroupCommand;
const de_AddTagsToOnPremisesInstancesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_AddTagsToOnPremisesInstancesCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_AddTagsToOnPremisesInstancesCommand = de_AddTagsToOnPremisesInstancesCommand;
const de_AddTagsToOnPremisesInstancesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InstanceLimitExceededException":
        case "com.amazonaws.codedeploy#InstanceLimitExceededException":
            throw await de_InstanceLimitExceededExceptionRes(parsedOutput, context);
        case "InstanceNameRequiredException":
        case "com.amazonaws.codedeploy#InstanceNameRequiredException":
            throw await de_InstanceNameRequiredExceptionRes(parsedOutput, context);
        case "InstanceNotRegisteredException":
        case "com.amazonaws.codedeploy#InstanceNotRegisteredException":
            throw await de_InstanceNotRegisteredExceptionRes(parsedOutput, context);
        case "InvalidInstanceNameException":
        case "com.amazonaws.codedeploy#InvalidInstanceNameException":
            throw await de_InvalidInstanceNameExceptionRes(parsedOutput, context);
        case "InvalidTagException":
        case "com.amazonaws.codedeploy#InvalidTagException":
            throw await de_InvalidTagExceptionRes(parsedOutput, context);
        case "TagLimitExceededException":
        case "com.amazonaws.codedeploy#TagLimitExceededException":
            throw await de_TagLimitExceededExceptionRes(parsedOutput, context);
        case "TagRequiredException":
        case "com.amazonaws.codedeploy#TagRequiredException":
            throw await de_TagRequiredExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_BatchGetApplicationRevisionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_BatchGetApplicationRevisionsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_BatchGetApplicationRevisionsOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_BatchGetApplicationRevisionsCommand = de_BatchGetApplicationRevisionsCommand;
const de_BatchGetApplicationRevisionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ApplicationDoesNotExistException":
        case "com.amazonaws.codedeploy#ApplicationDoesNotExistException":
            throw await de_ApplicationDoesNotExistExceptionRes(parsedOutput, context);
        case "ApplicationNameRequiredException":
        case "com.amazonaws.codedeploy#ApplicationNameRequiredException":
            throw await de_ApplicationNameRequiredExceptionRes(parsedOutput, context);
        case "BatchLimitExceededException":
        case "com.amazonaws.codedeploy#BatchLimitExceededException":
            throw await de_BatchLimitExceededExceptionRes(parsedOutput, context);
        case "InvalidApplicationNameException":
        case "com.amazonaws.codedeploy#InvalidApplicationNameException":
            throw await de_InvalidApplicationNameExceptionRes(parsedOutput, context);
        case "InvalidRevisionException":
        case "com.amazonaws.codedeploy#InvalidRevisionException":
            throw await de_InvalidRevisionExceptionRes(parsedOutput, context);
        case "RevisionRequiredException":
        case "com.amazonaws.codedeploy#RevisionRequiredException":
            throw await de_RevisionRequiredExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_BatchGetApplicationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_BatchGetApplicationsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_BatchGetApplicationsOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_BatchGetApplicationsCommand = de_BatchGetApplicationsCommand;
const de_BatchGetApplicationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ApplicationDoesNotExistException":
        case "com.amazonaws.codedeploy#ApplicationDoesNotExistException":
            throw await de_ApplicationDoesNotExistExceptionRes(parsedOutput, context);
        case "ApplicationNameRequiredException":
        case "com.amazonaws.codedeploy#ApplicationNameRequiredException":
            throw await de_ApplicationNameRequiredExceptionRes(parsedOutput, context);
        case "BatchLimitExceededException":
        case "com.amazonaws.codedeploy#BatchLimitExceededException":
            throw await de_BatchLimitExceededExceptionRes(parsedOutput, context);
        case "InvalidApplicationNameException":
        case "com.amazonaws.codedeploy#InvalidApplicationNameException":
            throw await de_InvalidApplicationNameExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_BatchGetDeploymentGroupsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_BatchGetDeploymentGroupsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_BatchGetDeploymentGroupsOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_BatchGetDeploymentGroupsCommand = de_BatchGetDeploymentGroupsCommand;
const de_BatchGetDeploymentGroupsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ApplicationDoesNotExistException":
        case "com.amazonaws.codedeploy#ApplicationDoesNotExistException":
            throw await de_ApplicationDoesNotExistExceptionRes(parsedOutput, context);
        case "ApplicationNameRequiredException":
        case "com.amazonaws.codedeploy#ApplicationNameRequiredException":
            throw await de_ApplicationNameRequiredExceptionRes(parsedOutput, context);
        case "BatchLimitExceededException":
        case "com.amazonaws.codedeploy#BatchLimitExceededException":
            throw await de_BatchLimitExceededExceptionRes(parsedOutput, context);
        case "DeploymentConfigDoesNotExistException":
        case "com.amazonaws.codedeploy#DeploymentConfigDoesNotExistException":
            throw await de_DeploymentConfigDoesNotExistExceptionRes(parsedOutput, context);
        case "DeploymentGroupNameRequiredException":
        case "com.amazonaws.codedeploy#DeploymentGroupNameRequiredException":
            throw await de_DeploymentGroupNameRequiredExceptionRes(parsedOutput, context);
        case "InvalidApplicationNameException":
        case "com.amazonaws.codedeploy#InvalidApplicationNameException":
            throw await de_InvalidApplicationNameExceptionRes(parsedOutput, context);
        case "InvalidDeploymentGroupNameException":
        case "com.amazonaws.codedeploy#InvalidDeploymentGroupNameException":
            throw await de_InvalidDeploymentGroupNameExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_BatchGetDeploymentInstancesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_BatchGetDeploymentInstancesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_BatchGetDeploymentInstancesOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_BatchGetDeploymentInstancesCommand = de_BatchGetDeploymentInstancesCommand;
const de_BatchGetDeploymentInstancesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BatchLimitExceededException":
        case "com.amazonaws.codedeploy#BatchLimitExceededException":
            throw await de_BatchLimitExceededExceptionRes(parsedOutput, context);
        case "DeploymentDoesNotExistException":
        case "com.amazonaws.codedeploy#DeploymentDoesNotExistException":
            throw await de_DeploymentDoesNotExistExceptionRes(parsedOutput, context);
        case "DeploymentIdRequiredException":
        case "com.amazonaws.codedeploy#DeploymentIdRequiredException":
            throw await de_DeploymentIdRequiredExceptionRes(parsedOutput, context);
        case "InstanceIdRequiredException":
        case "com.amazonaws.codedeploy#InstanceIdRequiredException":
            throw await de_InstanceIdRequiredExceptionRes(parsedOutput, context);
        case "InvalidComputePlatformException":
        case "com.amazonaws.codedeploy#InvalidComputePlatformException":
            throw await de_InvalidComputePlatformExceptionRes(parsedOutput, context);
        case "InvalidDeploymentIdException":
        case "com.amazonaws.codedeploy#InvalidDeploymentIdException":
            throw await de_InvalidDeploymentIdExceptionRes(parsedOutput, context);
        case "InvalidInstanceNameException":
        case "com.amazonaws.codedeploy#InvalidInstanceNameException":
            throw await de_InvalidInstanceNameExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_BatchGetDeploymentsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_BatchGetDeploymentsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_BatchGetDeploymentsOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_BatchGetDeploymentsCommand = de_BatchGetDeploymentsCommand;
const de_BatchGetDeploymentsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BatchLimitExceededException":
        case "com.amazonaws.codedeploy#BatchLimitExceededException":
            throw await de_BatchLimitExceededExceptionRes(parsedOutput, context);
        case "DeploymentIdRequiredException":
        case "com.amazonaws.codedeploy#DeploymentIdRequiredException":
            throw await de_DeploymentIdRequiredExceptionRes(parsedOutput, context);
        case "InvalidDeploymentIdException":
        case "com.amazonaws.codedeploy#InvalidDeploymentIdException":
            throw await de_InvalidDeploymentIdExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_BatchGetDeploymentTargetsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_BatchGetDeploymentTargetsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_BatchGetDeploymentTargetsOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_BatchGetDeploymentTargetsCommand = de_BatchGetDeploymentTargetsCommand;
const de_BatchGetDeploymentTargetsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeploymentDoesNotExistException":
        case "com.amazonaws.codedeploy#DeploymentDoesNotExistException":
            throw await de_DeploymentDoesNotExistExceptionRes(parsedOutput, context);
        case "DeploymentIdRequiredException":
        case "com.amazonaws.codedeploy#DeploymentIdRequiredException":
            throw await de_DeploymentIdRequiredExceptionRes(parsedOutput, context);
        case "DeploymentNotStartedException":
        case "com.amazonaws.codedeploy#DeploymentNotStartedException":
            throw await de_DeploymentNotStartedExceptionRes(parsedOutput, context);
        case "DeploymentTargetDoesNotExistException":
        case "com.amazonaws.codedeploy#DeploymentTargetDoesNotExistException":
            throw await de_DeploymentTargetDoesNotExistExceptionRes(parsedOutput, context);
        case "DeploymentTargetIdRequiredException":
        case "com.amazonaws.codedeploy#DeploymentTargetIdRequiredException":
            throw await de_DeploymentTargetIdRequiredExceptionRes(parsedOutput, context);
        case "DeploymentTargetListSizeExceededException":
        case "com.amazonaws.codedeploy#DeploymentTargetListSizeExceededException":
            throw await de_DeploymentTargetListSizeExceededExceptionRes(parsedOutput, context);
        case "InstanceDoesNotExistException":
        case "com.amazonaws.codedeploy#InstanceDoesNotExistException":
            throw await de_InstanceDoesNotExistExceptionRes(parsedOutput, context);
        case "InvalidDeploymentIdException":
        case "com.amazonaws.codedeploy#InvalidDeploymentIdException":
            throw await de_InvalidDeploymentIdExceptionRes(parsedOutput, context);
        case "InvalidDeploymentTargetIdException":
        case "com.amazonaws.codedeploy#InvalidDeploymentTargetIdException":
            throw await de_InvalidDeploymentTargetIdExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_BatchGetOnPremisesInstancesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_BatchGetOnPremisesInstancesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_BatchGetOnPremisesInstancesOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_BatchGetOnPremisesInstancesCommand = de_BatchGetOnPremisesInstancesCommand;
const de_BatchGetOnPremisesInstancesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BatchLimitExceededException":
        case "com.amazonaws.codedeploy#BatchLimitExceededException":
            throw await de_BatchLimitExceededExceptionRes(parsedOutput, context);
        case "InstanceNameRequiredException":
        case "com.amazonaws.codedeploy#InstanceNameRequiredException":
            throw await de_InstanceNameRequiredExceptionRes(parsedOutput, context);
        case "InvalidInstanceNameException":
        case "com.amazonaws.codedeploy#InvalidInstanceNameException":
            throw await de_InvalidInstanceNameExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ContinueDeploymentCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ContinueDeploymentCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_ContinueDeploymentCommand = de_ContinueDeploymentCommand;
const de_ContinueDeploymentCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeploymentAlreadyCompletedException":
        case "com.amazonaws.codedeploy#DeploymentAlreadyCompletedException":
            throw await de_DeploymentAlreadyCompletedExceptionRes(parsedOutput, context);
        case "DeploymentDoesNotExistException":
        case "com.amazonaws.codedeploy#DeploymentDoesNotExistException":
            throw await de_DeploymentDoesNotExistExceptionRes(parsedOutput, context);
        case "DeploymentIdRequiredException":
        case "com.amazonaws.codedeploy#DeploymentIdRequiredException":
            throw await de_DeploymentIdRequiredExceptionRes(parsedOutput, context);
        case "DeploymentIsNotInReadyStateException":
        case "com.amazonaws.codedeploy#DeploymentIsNotInReadyStateException":
            throw await de_DeploymentIsNotInReadyStateExceptionRes(parsedOutput, context);
        case "InvalidDeploymentIdException":
        case "com.amazonaws.codedeploy#InvalidDeploymentIdException":
            throw await de_InvalidDeploymentIdExceptionRes(parsedOutput, context);
        case "InvalidDeploymentStatusException":
        case "com.amazonaws.codedeploy#InvalidDeploymentStatusException":
            throw await de_InvalidDeploymentStatusExceptionRes(parsedOutput, context);
        case "InvalidDeploymentWaitTypeException":
        case "com.amazonaws.codedeploy#InvalidDeploymentWaitTypeException":
            throw await de_InvalidDeploymentWaitTypeExceptionRes(parsedOutput, context);
        case "UnsupportedActionForDeploymentTypeException":
        case "com.amazonaws.codedeploy#UnsupportedActionForDeploymentTypeException":
            throw await de_UnsupportedActionForDeploymentTypeExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateApplicationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateApplicationCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_CreateApplicationCommand = de_CreateApplicationCommand;
const de_CreateApplicationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ApplicationAlreadyExistsException":
        case "com.amazonaws.codedeploy#ApplicationAlreadyExistsException":
            throw await de_ApplicationAlreadyExistsExceptionRes(parsedOutput, context);
        case "ApplicationLimitExceededException":
        case "com.amazonaws.codedeploy#ApplicationLimitExceededException":
            throw await de_ApplicationLimitExceededExceptionRes(parsedOutput, context);
        case "ApplicationNameRequiredException":
        case "com.amazonaws.codedeploy#ApplicationNameRequiredException":
            throw await de_ApplicationNameRequiredExceptionRes(parsedOutput, context);
        case "InvalidApplicationNameException":
        case "com.amazonaws.codedeploy#InvalidApplicationNameException":
            throw await de_InvalidApplicationNameExceptionRes(parsedOutput, context);
        case "InvalidComputePlatformException":
        case "com.amazonaws.codedeploy#InvalidComputePlatformException":
            throw await de_InvalidComputePlatformExceptionRes(parsedOutput, context);
        case "InvalidTagsToAddException":
        case "com.amazonaws.codedeploy#InvalidTagsToAddException":
            throw await de_InvalidTagsToAddExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateDeploymentCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateDeploymentCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_CreateDeploymentCommand = de_CreateDeploymentCommand;
const de_CreateDeploymentCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AlarmsLimitExceededException":
        case "com.amazonaws.codedeploy#AlarmsLimitExceededException":
            throw await de_AlarmsLimitExceededExceptionRes(parsedOutput, context);
        case "ApplicationDoesNotExistException":
        case "com.amazonaws.codedeploy#ApplicationDoesNotExistException":
            throw await de_ApplicationDoesNotExistExceptionRes(parsedOutput, context);
        case "ApplicationNameRequiredException":
        case "com.amazonaws.codedeploy#ApplicationNameRequiredException":
            throw await de_ApplicationNameRequiredExceptionRes(parsedOutput, context);
        case "DeploymentConfigDoesNotExistException":
        case "com.amazonaws.codedeploy#DeploymentConfigDoesNotExistException":
            throw await de_DeploymentConfigDoesNotExistExceptionRes(parsedOutput, context);
        case "DeploymentGroupDoesNotExistException":
        case "com.amazonaws.codedeploy#DeploymentGroupDoesNotExistException":
            throw await de_DeploymentGroupDoesNotExistExceptionRes(parsedOutput, context);
        case "DeploymentGroupNameRequiredException":
        case "com.amazonaws.codedeploy#DeploymentGroupNameRequiredException":
            throw await de_DeploymentGroupNameRequiredExceptionRes(parsedOutput, context);
        case "DeploymentLimitExceededException":
        case "com.amazonaws.codedeploy#DeploymentLimitExceededException":
            throw await de_DeploymentLimitExceededExceptionRes(parsedOutput, context);
        case "DescriptionTooLongException":
        case "com.amazonaws.codedeploy#DescriptionTooLongException":
            throw await de_DescriptionTooLongExceptionRes(parsedOutput, context);
        case "InvalidAlarmConfigException":
        case "com.amazonaws.codedeploy#InvalidAlarmConfigException":
            throw await de_InvalidAlarmConfigExceptionRes(parsedOutput, context);
        case "InvalidApplicationNameException":
        case "com.amazonaws.codedeploy#InvalidApplicationNameException":
            throw await de_InvalidApplicationNameExceptionRes(parsedOutput, context);
        case "InvalidAutoRollbackConfigException":
        case "com.amazonaws.codedeploy#InvalidAutoRollbackConfigException":
            throw await de_InvalidAutoRollbackConfigExceptionRes(parsedOutput, context);
        case "InvalidAutoScalingGroupException":
        case "com.amazonaws.codedeploy#InvalidAutoScalingGroupException":
            throw await de_InvalidAutoScalingGroupExceptionRes(parsedOutput, context);
        case "InvalidDeploymentConfigNameException":
        case "com.amazonaws.codedeploy#InvalidDeploymentConfigNameException":
            throw await de_InvalidDeploymentConfigNameExceptionRes(parsedOutput, context);
        case "InvalidDeploymentGroupNameException":
        case "com.amazonaws.codedeploy#InvalidDeploymentGroupNameException":
            throw await de_InvalidDeploymentGroupNameExceptionRes(parsedOutput, context);
        case "InvalidFileExistsBehaviorException":
        case "com.amazonaws.codedeploy#InvalidFileExistsBehaviorException":
            throw await de_InvalidFileExistsBehaviorExceptionRes(parsedOutput, context);
        case "InvalidGitHubAccountTokenException":
        case "com.amazonaws.codedeploy#InvalidGitHubAccountTokenException":
            throw await de_InvalidGitHubAccountTokenExceptionRes(parsedOutput, context);
        case "InvalidIgnoreApplicationStopFailuresValueException":
        case "com.amazonaws.codedeploy#InvalidIgnoreApplicationStopFailuresValueException":
            throw await de_InvalidIgnoreApplicationStopFailuresValueExceptionRes(parsedOutput, context);
        case "InvalidLoadBalancerInfoException":
        case "com.amazonaws.codedeploy#InvalidLoadBalancerInfoException":
            throw await de_InvalidLoadBalancerInfoExceptionRes(parsedOutput, context);
        case "InvalidRevisionException":
        case "com.amazonaws.codedeploy#InvalidRevisionException":
            throw await de_InvalidRevisionExceptionRes(parsedOutput, context);
        case "InvalidRoleException":
        case "com.amazonaws.codedeploy#InvalidRoleException":
            throw await de_InvalidRoleExceptionRes(parsedOutput, context);
        case "InvalidTargetInstancesException":
        case "com.amazonaws.codedeploy#InvalidTargetInstancesException":
            throw await de_InvalidTargetInstancesExceptionRes(parsedOutput, context);
        case "InvalidTrafficRoutingConfigurationException":
        case "com.amazonaws.codedeploy#InvalidTrafficRoutingConfigurationException":
            throw await de_InvalidTrafficRoutingConfigurationExceptionRes(parsedOutput, context);
        case "InvalidUpdateOutdatedInstancesOnlyValueException":
        case "com.amazonaws.codedeploy#InvalidUpdateOutdatedInstancesOnlyValueException":
            throw await de_InvalidUpdateOutdatedInstancesOnlyValueExceptionRes(parsedOutput, context);
        case "RevisionDoesNotExistException":
        case "com.amazonaws.codedeploy#RevisionDoesNotExistException":
            throw await de_RevisionDoesNotExistExceptionRes(parsedOutput, context);
        case "RevisionRequiredException":
        case "com.amazonaws.codedeploy#RevisionRequiredException":
            throw await de_RevisionRequiredExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.codedeploy#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateDeploymentConfigCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateDeploymentConfigCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_CreateDeploymentConfigCommand = de_CreateDeploymentConfigCommand;
const de_CreateDeploymentConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeploymentConfigAlreadyExistsException":
        case "com.amazonaws.codedeploy#DeploymentConfigAlreadyExistsException":
            throw await de_DeploymentConfigAlreadyExistsExceptionRes(parsedOutput, context);
        case "DeploymentConfigLimitExceededException":
        case "com.amazonaws.codedeploy#DeploymentConfigLimitExceededException":
            throw await de_DeploymentConfigLimitExceededExceptionRes(parsedOutput, context);
        case "DeploymentConfigNameRequiredException":
        case "com.amazonaws.codedeploy#DeploymentConfigNameRequiredException":
            throw await de_DeploymentConfigNameRequiredExceptionRes(parsedOutput, context);
        case "InvalidComputePlatformException":
        case "com.amazonaws.codedeploy#InvalidComputePlatformException":
            throw await de_InvalidComputePlatformExceptionRes(parsedOutput, context);
        case "InvalidDeploymentConfigNameException":
        case "com.amazonaws.codedeploy#InvalidDeploymentConfigNameException":
            throw await de_InvalidDeploymentConfigNameExceptionRes(parsedOutput, context);
        case "InvalidMinimumHealthyHostValueException":
        case "com.amazonaws.codedeploy#InvalidMinimumHealthyHostValueException":
            throw await de_InvalidMinimumHealthyHostValueExceptionRes(parsedOutput, context);
        case "InvalidTrafficRoutingConfigurationException":
        case "com.amazonaws.codedeploy#InvalidTrafficRoutingConfigurationException":
            throw await de_InvalidTrafficRoutingConfigurationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateDeploymentGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateDeploymentGroupCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_CreateDeploymentGroupCommand = de_CreateDeploymentGroupCommand;
const de_CreateDeploymentGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AlarmsLimitExceededException":
        case "com.amazonaws.codedeploy#AlarmsLimitExceededException":
            throw await de_AlarmsLimitExceededExceptionRes(parsedOutput, context);
        case "ApplicationDoesNotExistException":
        case "com.amazonaws.codedeploy#ApplicationDoesNotExistException":
            throw await de_ApplicationDoesNotExistExceptionRes(parsedOutput, context);
        case "ApplicationNameRequiredException":
        case "com.amazonaws.codedeploy#ApplicationNameRequiredException":
            throw await de_ApplicationNameRequiredExceptionRes(parsedOutput, context);
        case "DeploymentConfigDoesNotExistException":
        case "com.amazonaws.codedeploy#DeploymentConfigDoesNotExistException":
            throw await de_DeploymentConfigDoesNotExistExceptionRes(parsedOutput, context);
        case "DeploymentGroupAlreadyExistsException":
        case "com.amazonaws.codedeploy#DeploymentGroupAlreadyExistsException":
            throw await de_DeploymentGroupAlreadyExistsExceptionRes(parsedOutput, context);
        case "DeploymentGroupLimitExceededException":
        case "com.amazonaws.codedeploy#DeploymentGroupLimitExceededException":
            throw await de_DeploymentGroupLimitExceededExceptionRes(parsedOutput, context);
        case "DeploymentGroupNameRequiredException":
        case "com.amazonaws.codedeploy#DeploymentGroupNameRequiredException":
            throw await de_DeploymentGroupNameRequiredExceptionRes(parsedOutput, context);
        case "ECSServiceMappingLimitExceededException":
        case "com.amazonaws.codedeploy#ECSServiceMappingLimitExceededException":
            throw await de_ECSServiceMappingLimitExceededExceptionRes(parsedOutput, context);
        case "InvalidAlarmConfigException":
        case "com.amazonaws.codedeploy#InvalidAlarmConfigException":
            throw await de_InvalidAlarmConfigExceptionRes(parsedOutput, context);
        case "InvalidApplicationNameException":
        case "com.amazonaws.codedeploy#InvalidApplicationNameException":
            throw await de_InvalidApplicationNameExceptionRes(parsedOutput, context);
        case "InvalidAutoRollbackConfigException":
        case "com.amazonaws.codedeploy#InvalidAutoRollbackConfigException":
            throw await de_InvalidAutoRollbackConfigExceptionRes(parsedOutput, context);
        case "InvalidAutoScalingGroupException":
        case "com.amazonaws.codedeploy#InvalidAutoScalingGroupException":
            throw await de_InvalidAutoScalingGroupExceptionRes(parsedOutput, context);
        case "InvalidBlueGreenDeploymentConfigurationException":
        case "com.amazonaws.codedeploy#InvalidBlueGreenDeploymentConfigurationException":
            throw await de_InvalidBlueGreenDeploymentConfigurationExceptionRes(parsedOutput, context);
        case "InvalidDeploymentConfigNameException":
        case "com.amazonaws.codedeploy#InvalidDeploymentConfigNameException":
            throw await de_InvalidDeploymentConfigNameExceptionRes(parsedOutput, context);
        case "InvalidDeploymentGroupNameException":
        case "com.amazonaws.codedeploy#InvalidDeploymentGroupNameException":
            throw await de_InvalidDeploymentGroupNameExceptionRes(parsedOutput, context);
        case "InvalidDeploymentStyleException":
        case "com.amazonaws.codedeploy#InvalidDeploymentStyleException":
            throw await de_InvalidDeploymentStyleExceptionRes(parsedOutput, context);
        case "InvalidEC2TagCombinationException":
        case "com.amazonaws.codedeploy#InvalidEC2TagCombinationException":
            throw await de_InvalidEC2TagCombinationExceptionRes(parsedOutput, context);
        case "InvalidEC2TagException":
        case "com.amazonaws.codedeploy#InvalidEC2TagException":
            throw await de_InvalidEC2TagExceptionRes(parsedOutput, context);
        case "InvalidECSServiceException":
        case "com.amazonaws.codedeploy#InvalidECSServiceException":
            throw await de_InvalidECSServiceExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.codedeploy#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "InvalidLoadBalancerInfoException":
        case "com.amazonaws.codedeploy#InvalidLoadBalancerInfoException":
            throw await de_InvalidLoadBalancerInfoExceptionRes(parsedOutput, context);
        case "InvalidOnPremisesTagCombinationException":
        case "com.amazonaws.codedeploy#InvalidOnPremisesTagCombinationException":
            throw await de_InvalidOnPremisesTagCombinationExceptionRes(parsedOutput, context);
        case "InvalidRoleException":
        case "com.amazonaws.codedeploy#InvalidRoleException":
            throw await de_InvalidRoleExceptionRes(parsedOutput, context);
        case "InvalidTagException":
        case "com.amazonaws.codedeploy#InvalidTagException":
            throw await de_InvalidTagExceptionRes(parsedOutput, context);
        case "InvalidTagsToAddException":
        case "com.amazonaws.codedeploy#InvalidTagsToAddException":
            throw await de_InvalidTagsToAddExceptionRes(parsedOutput, context);
        case "InvalidTargetGroupPairException":
        case "com.amazonaws.codedeploy#InvalidTargetGroupPairException":
            throw await de_InvalidTargetGroupPairExceptionRes(parsedOutput, context);
        case "InvalidTrafficRoutingConfigurationException":
        case "com.amazonaws.codedeploy#InvalidTrafficRoutingConfigurationException":
            throw await de_InvalidTrafficRoutingConfigurationExceptionRes(parsedOutput, context);
        case "InvalidTriggerConfigException":
        case "com.amazonaws.codedeploy#InvalidTriggerConfigException":
            throw await de_InvalidTriggerConfigExceptionRes(parsedOutput, context);
        case "LifecycleHookLimitExceededException":
        case "com.amazonaws.codedeploy#LifecycleHookLimitExceededException":
            throw await de_LifecycleHookLimitExceededExceptionRes(parsedOutput, context);
        case "RoleRequiredException":
        case "com.amazonaws.codedeploy#RoleRequiredException":
            throw await de_RoleRequiredExceptionRes(parsedOutput, context);
        case "TagSetListLimitExceededException":
        case "com.amazonaws.codedeploy#TagSetListLimitExceededException":
            throw await de_TagSetListLimitExceededExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.codedeploy#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "TriggerTargetsLimitExceededException":
        case "com.amazonaws.codedeploy#TriggerTargetsLimitExceededException":
            throw await de_TriggerTargetsLimitExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteApplicationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteApplicationCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_DeleteApplicationCommand = de_DeleteApplicationCommand;
const de_DeleteApplicationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ApplicationNameRequiredException":
        case "com.amazonaws.codedeploy#ApplicationNameRequiredException":
            throw await de_ApplicationNameRequiredExceptionRes(parsedOutput, context);
        case "InvalidApplicationNameException":
        case "com.amazonaws.codedeploy#InvalidApplicationNameException":
            throw await de_InvalidApplicationNameExceptionRes(parsedOutput, context);
        case "InvalidRoleException":
        case "com.amazonaws.codedeploy#InvalidRoleException":
            throw await de_InvalidRoleExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteDeploymentConfigCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteDeploymentConfigCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_DeleteDeploymentConfigCommand = de_DeleteDeploymentConfigCommand;
const de_DeleteDeploymentConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeploymentConfigInUseException":
        case "com.amazonaws.codedeploy#DeploymentConfigInUseException":
            throw await de_DeploymentConfigInUseExceptionRes(parsedOutput, context);
        case "DeploymentConfigNameRequiredException":
        case "com.amazonaws.codedeploy#DeploymentConfigNameRequiredException":
            throw await de_DeploymentConfigNameRequiredExceptionRes(parsedOutput, context);
        case "InvalidDeploymentConfigNameException":
        case "com.amazonaws.codedeploy#InvalidDeploymentConfigNameException":
            throw await de_InvalidDeploymentConfigNameExceptionRes(parsedOutput, context);
        case "InvalidOperationException":
        case "com.amazonaws.codedeploy#InvalidOperationException":
            throw await de_InvalidOperationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteDeploymentGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteDeploymentGroupCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_DeleteDeploymentGroupCommand = de_DeleteDeploymentGroupCommand;
const de_DeleteDeploymentGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ApplicationNameRequiredException":
        case "com.amazonaws.codedeploy#ApplicationNameRequiredException":
            throw await de_ApplicationNameRequiredExceptionRes(parsedOutput, context);
        case "DeploymentGroupNameRequiredException":
        case "com.amazonaws.codedeploy#DeploymentGroupNameRequiredException":
            throw await de_DeploymentGroupNameRequiredExceptionRes(parsedOutput, context);
        case "InvalidApplicationNameException":
        case "com.amazonaws.codedeploy#InvalidApplicationNameException":
            throw await de_InvalidApplicationNameExceptionRes(parsedOutput, context);
        case "InvalidDeploymentGroupNameException":
        case "com.amazonaws.codedeploy#InvalidDeploymentGroupNameException":
            throw await de_InvalidDeploymentGroupNameExceptionRes(parsedOutput, context);
        case "InvalidRoleException":
        case "com.amazonaws.codedeploy#InvalidRoleException":
            throw await de_InvalidRoleExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteGitHubAccountTokenCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteGitHubAccountTokenCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_DeleteGitHubAccountTokenCommand = de_DeleteGitHubAccountTokenCommand;
const de_DeleteGitHubAccountTokenCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "GitHubAccountTokenDoesNotExistException":
        case "com.amazonaws.codedeploy#GitHubAccountTokenDoesNotExistException":
            throw await de_GitHubAccountTokenDoesNotExistExceptionRes(parsedOutput, context);
        case "GitHubAccountTokenNameRequiredException":
        case "com.amazonaws.codedeploy#GitHubAccountTokenNameRequiredException":
            throw await de_GitHubAccountTokenNameRequiredExceptionRes(parsedOutput, context);
        case "InvalidGitHubAccountTokenNameException":
        case "com.amazonaws.codedeploy#InvalidGitHubAccountTokenNameException":
            throw await de_InvalidGitHubAccountTokenNameExceptionRes(parsedOutput, context);
        case "OperationNotSupportedException":
        case "com.amazonaws.codedeploy#OperationNotSupportedException":
            throw await de_OperationNotSupportedExceptionRes(parsedOutput, context);
        case "ResourceValidationException":
        case "com.amazonaws.codedeploy#ResourceValidationException":
            throw await de_ResourceValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteResourcesByExternalIdCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteResourcesByExternalIdCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_DeleteResourcesByExternalIdCommand = de_DeleteResourcesByExternalIdCommand;
const de_DeleteResourcesByExternalIdCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_DeregisterOnPremisesInstanceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeregisterOnPremisesInstanceCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_DeregisterOnPremisesInstanceCommand = de_DeregisterOnPremisesInstanceCommand;
const de_DeregisterOnPremisesInstanceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InstanceNameRequiredException":
        case "com.amazonaws.codedeploy#InstanceNameRequiredException":
            throw await de_InstanceNameRequiredExceptionRes(parsedOutput, context);
        case "InvalidInstanceNameException":
        case "com.amazonaws.codedeploy#InvalidInstanceNameException":
            throw await de_InvalidInstanceNameExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetApplicationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetApplicationCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetApplicationOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetApplicationCommand = de_GetApplicationCommand;
const de_GetApplicationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ApplicationDoesNotExistException":
        case "com.amazonaws.codedeploy#ApplicationDoesNotExistException":
            throw await de_ApplicationDoesNotExistExceptionRes(parsedOutput, context);
        case "ApplicationNameRequiredException":
        case "com.amazonaws.codedeploy#ApplicationNameRequiredException":
            throw await de_ApplicationNameRequiredExceptionRes(parsedOutput, context);
        case "InvalidApplicationNameException":
        case "com.amazonaws.codedeploy#InvalidApplicationNameException":
            throw await de_InvalidApplicationNameExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetApplicationRevisionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetApplicationRevisionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetApplicationRevisionOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetApplicationRevisionCommand = de_GetApplicationRevisionCommand;
const de_GetApplicationRevisionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ApplicationDoesNotExistException":
        case "com.amazonaws.codedeploy#ApplicationDoesNotExistException":
            throw await de_ApplicationDoesNotExistExceptionRes(parsedOutput, context);
        case "ApplicationNameRequiredException":
        case "com.amazonaws.codedeploy#ApplicationNameRequiredException":
            throw await de_ApplicationNameRequiredExceptionRes(parsedOutput, context);
        case "InvalidApplicationNameException":
        case "com.amazonaws.codedeploy#InvalidApplicationNameException":
            throw await de_InvalidApplicationNameExceptionRes(parsedOutput, context);
        case "InvalidRevisionException":
        case "com.amazonaws.codedeploy#InvalidRevisionException":
            throw await de_InvalidRevisionExceptionRes(parsedOutput, context);
        case "RevisionDoesNotExistException":
        case "com.amazonaws.codedeploy#RevisionDoesNotExistException":
            throw await de_RevisionDoesNotExistExceptionRes(parsedOutput, context);
        case "RevisionRequiredException":
        case "com.amazonaws.codedeploy#RevisionRequiredException":
            throw await de_RevisionRequiredExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetDeploymentCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetDeploymentCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetDeploymentOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetDeploymentCommand = de_GetDeploymentCommand;
const de_GetDeploymentCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeploymentDoesNotExistException":
        case "com.amazonaws.codedeploy#DeploymentDoesNotExistException":
            throw await de_DeploymentDoesNotExistExceptionRes(parsedOutput, context);
        case "DeploymentIdRequiredException":
        case "com.amazonaws.codedeploy#DeploymentIdRequiredException":
            throw await de_DeploymentIdRequiredExceptionRes(parsedOutput, context);
        case "InvalidDeploymentIdException":
        case "com.amazonaws.codedeploy#InvalidDeploymentIdException":
            throw await de_InvalidDeploymentIdExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetDeploymentConfigCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetDeploymentConfigCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetDeploymentConfigOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetDeploymentConfigCommand = de_GetDeploymentConfigCommand;
const de_GetDeploymentConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeploymentConfigDoesNotExistException":
        case "com.amazonaws.codedeploy#DeploymentConfigDoesNotExistException":
            throw await de_DeploymentConfigDoesNotExistExceptionRes(parsedOutput, context);
        case "DeploymentConfigNameRequiredException":
        case "com.amazonaws.codedeploy#DeploymentConfigNameRequiredException":
            throw await de_DeploymentConfigNameRequiredExceptionRes(parsedOutput, context);
        case "InvalidComputePlatformException":
        case "com.amazonaws.codedeploy#InvalidComputePlatformException":
            throw await de_InvalidComputePlatformExceptionRes(parsedOutput, context);
        case "InvalidDeploymentConfigNameException":
        case "com.amazonaws.codedeploy#InvalidDeploymentConfigNameException":
            throw await de_InvalidDeploymentConfigNameExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetDeploymentGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetDeploymentGroupCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetDeploymentGroupOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetDeploymentGroupCommand = de_GetDeploymentGroupCommand;
const de_GetDeploymentGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ApplicationDoesNotExistException":
        case "com.amazonaws.codedeploy#ApplicationDoesNotExistException":
            throw await de_ApplicationDoesNotExistExceptionRes(parsedOutput, context);
        case "ApplicationNameRequiredException":
        case "com.amazonaws.codedeploy#ApplicationNameRequiredException":
            throw await de_ApplicationNameRequiredExceptionRes(parsedOutput, context);
        case "DeploymentConfigDoesNotExistException":
        case "com.amazonaws.codedeploy#DeploymentConfigDoesNotExistException":
            throw await de_DeploymentConfigDoesNotExistExceptionRes(parsedOutput, context);
        case "DeploymentGroupDoesNotExistException":
        case "com.amazonaws.codedeploy#DeploymentGroupDoesNotExistException":
            throw await de_DeploymentGroupDoesNotExistExceptionRes(parsedOutput, context);
        case "DeploymentGroupNameRequiredException":
        case "com.amazonaws.codedeploy#DeploymentGroupNameRequiredException":
            throw await de_DeploymentGroupNameRequiredExceptionRes(parsedOutput, context);
        case "InvalidApplicationNameException":
        case "com.amazonaws.codedeploy#InvalidApplicationNameException":
            throw await de_InvalidApplicationNameExceptionRes(parsedOutput, context);
        case "InvalidDeploymentGroupNameException":
        case "com.amazonaws.codedeploy#InvalidDeploymentGroupNameException":
            throw await de_InvalidDeploymentGroupNameExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetDeploymentInstanceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetDeploymentInstanceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetDeploymentInstanceOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetDeploymentInstanceCommand = de_GetDeploymentInstanceCommand;
const de_GetDeploymentInstanceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeploymentDoesNotExistException":
        case "com.amazonaws.codedeploy#DeploymentDoesNotExistException":
            throw await de_DeploymentDoesNotExistExceptionRes(parsedOutput, context);
        case "DeploymentIdRequiredException":
        case "com.amazonaws.codedeploy#DeploymentIdRequiredException":
            throw await de_DeploymentIdRequiredExceptionRes(parsedOutput, context);
        case "InstanceDoesNotExistException":
        case "com.amazonaws.codedeploy#InstanceDoesNotExistException":
            throw await de_InstanceDoesNotExistExceptionRes(parsedOutput, context);
        case "InstanceIdRequiredException":
        case "com.amazonaws.codedeploy#InstanceIdRequiredException":
            throw await de_InstanceIdRequiredExceptionRes(parsedOutput, context);
        case "InvalidComputePlatformException":
        case "com.amazonaws.codedeploy#InvalidComputePlatformException":
            throw await de_InvalidComputePlatformExceptionRes(parsedOutput, context);
        case "InvalidDeploymentIdException":
        case "com.amazonaws.codedeploy#InvalidDeploymentIdException":
            throw await de_InvalidDeploymentIdExceptionRes(parsedOutput, context);
        case "InvalidInstanceNameException":
        case "com.amazonaws.codedeploy#InvalidInstanceNameException":
            throw await de_InvalidInstanceNameExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetDeploymentTargetCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetDeploymentTargetCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetDeploymentTargetOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetDeploymentTargetCommand = de_GetDeploymentTargetCommand;
const de_GetDeploymentTargetCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeploymentDoesNotExistException":
        case "com.amazonaws.codedeploy#DeploymentDoesNotExistException":
            throw await de_DeploymentDoesNotExistExceptionRes(parsedOutput, context);
        case "DeploymentIdRequiredException":
        case "com.amazonaws.codedeploy#DeploymentIdRequiredException":
            throw await de_DeploymentIdRequiredExceptionRes(parsedOutput, context);
        case "DeploymentNotStartedException":
        case "com.amazonaws.codedeploy#DeploymentNotStartedException":
            throw await de_DeploymentNotStartedExceptionRes(parsedOutput, context);
        case "DeploymentTargetDoesNotExistException":
        case "com.amazonaws.codedeploy#DeploymentTargetDoesNotExistException":
            throw await de_DeploymentTargetDoesNotExistExceptionRes(parsedOutput, context);
        case "DeploymentTargetIdRequiredException":
        case "com.amazonaws.codedeploy#DeploymentTargetIdRequiredException":
            throw await de_DeploymentTargetIdRequiredExceptionRes(parsedOutput, context);
        case "InvalidDeploymentIdException":
        case "com.amazonaws.codedeploy#InvalidDeploymentIdException":
            throw await de_InvalidDeploymentIdExceptionRes(parsedOutput, context);
        case "InvalidDeploymentTargetIdException":
        case "com.amazonaws.codedeploy#InvalidDeploymentTargetIdException":
            throw await de_InvalidDeploymentTargetIdExceptionRes(parsedOutput, context);
        case "InvalidInstanceNameException":
        case "com.amazonaws.codedeploy#InvalidInstanceNameException":
            throw await de_InvalidInstanceNameExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetOnPremisesInstanceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetOnPremisesInstanceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetOnPremisesInstanceOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetOnPremisesInstanceCommand = de_GetOnPremisesInstanceCommand;
const de_GetOnPremisesInstanceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InstanceNameRequiredException":
        case "com.amazonaws.codedeploy#InstanceNameRequiredException":
            throw await de_InstanceNameRequiredExceptionRes(parsedOutput, context);
        case "InstanceNotRegisteredException":
        case "com.amazonaws.codedeploy#InstanceNotRegisteredException":
            throw await de_InstanceNotRegisteredExceptionRes(parsedOutput, context);
        case "InvalidInstanceNameException":
        case "com.amazonaws.codedeploy#InvalidInstanceNameException":
            throw await de_InvalidInstanceNameExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListApplicationRevisionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListApplicationRevisionsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListApplicationRevisionsCommand = de_ListApplicationRevisionsCommand;
const de_ListApplicationRevisionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ApplicationDoesNotExistException":
        case "com.amazonaws.codedeploy#ApplicationDoesNotExistException":
            throw await de_ApplicationDoesNotExistExceptionRes(parsedOutput, context);
        case "ApplicationNameRequiredException":
        case "com.amazonaws.codedeploy#ApplicationNameRequiredException":
            throw await de_ApplicationNameRequiredExceptionRes(parsedOutput, context);
        case "BucketNameFilterRequiredException":
        case "com.amazonaws.codedeploy#BucketNameFilterRequiredException":
            throw await de_BucketNameFilterRequiredExceptionRes(parsedOutput, context);
        case "InvalidApplicationNameException":
        case "com.amazonaws.codedeploy#InvalidApplicationNameException":
            throw await de_InvalidApplicationNameExceptionRes(parsedOutput, context);
        case "InvalidBucketNameFilterException":
        case "com.amazonaws.codedeploy#InvalidBucketNameFilterException":
            throw await de_InvalidBucketNameFilterExceptionRes(parsedOutput, context);
        case "InvalidDeployedStateFilterException":
        case "com.amazonaws.codedeploy#InvalidDeployedStateFilterException":
            throw await de_InvalidDeployedStateFilterExceptionRes(parsedOutput, context);
        case "InvalidKeyPrefixFilterException":
        case "com.amazonaws.codedeploy#InvalidKeyPrefixFilterException":
            throw await de_InvalidKeyPrefixFilterExceptionRes(parsedOutput, context);
        case "InvalidNextTokenException":
        case "com.amazonaws.codedeploy#InvalidNextTokenException":
            throw await de_InvalidNextTokenExceptionRes(parsedOutput, context);
        case "InvalidSortByException":
        case "com.amazonaws.codedeploy#InvalidSortByException":
            throw await de_InvalidSortByExceptionRes(parsedOutput, context);
        case "InvalidSortOrderException":
        case "com.amazonaws.codedeploy#InvalidSortOrderException":
            throw await de_InvalidSortOrderExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListApplicationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListApplicationsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListApplicationsCommand = de_ListApplicationsCommand;
const de_ListApplicationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidNextTokenException":
        case "com.amazonaws.codedeploy#InvalidNextTokenException":
            throw await de_InvalidNextTokenExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListDeploymentConfigsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListDeploymentConfigsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListDeploymentConfigsCommand = de_ListDeploymentConfigsCommand;
const de_ListDeploymentConfigsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidNextTokenException":
        case "com.amazonaws.codedeploy#InvalidNextTokenException":
            throw await de_InvalidNextTokenExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListDeploymentGroupsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListDeploymentGroupsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListDeploymentGroupsCommand = de_ListDeploymentGroupsCommand;
const de_ListDeploymentGroupsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ApplicationDoesNotExistException":
        case "com.amazonaws.codedeploy#ApplicationDoesNotExistException":
            throw await de_ApplicationDoesNotExistExceptionRes(parsedOutput, context);
        case "ApplicationNameRequiredException":
        case "com.amazonaws.codedeploy#ApplicationNameRequiredException":
            throw await de_ApplicationNameRequiredExceptionRes(parsedOutput, context);
        case "InvalidApplicationNameException":
        case "com.amazonaws.codedeploy#InvalidApplicationNameException":
            throw await de_InvalidApplicationNameExceptionRes(parsedOutput, context);
        case "InvalidNextTokenException":
        case "com.amazonaws.codedeploy#InvalidNextTokenException":
            throw await de_InvalidNextTokenExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListDeploymentInstancesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListDeploymentInstancesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListDeploymentInstancesCommand = de_ListDeploymentInstancesCommand;
const de_ListDeploymentInstancesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeploymentDoesNotExistException":
        case "com.amazonaws.codedeploy#DeploymentDoesNotExistException":
            throw await de_DeploymentDoesNotExistExceptionRes(parsedOutput, context);
        case "DeploymentIdRequiredException":
        case "com.amazonaws.codedeploy#DeploymentIdRequiredException":
            throw await de_DeploymentIdRequiredExceptionRes(parsedOutput, context);
        case "DeploymentNotStartedException":
        case "com.amazonaws.codedeploy#DeploymentNotStartedException":
            throw await de_DeploymentNotStartedExceptionRes(parsedOutput, context);
        case "InvalidComputePlatformException":
        case "com.amazonaws.codedeploy#InvalidComputePlatformException":
            throw await de_InvalidComputePlatformExceptionRes(parsedOutput, context);
        case "InvalidDeploymentIdException":
        case "com.amazonaws.codedeploy#InvalidDeploymentIdException":
            throw await de_InvalidDeploymentIdExceptionRes(parsedOutput, context);
        case "InvalidDeploymentInstanceTypeException":
        case "com.amazonaws.codedeploy#InvalidDeploymentInstanceTypeException":
            throw await de_InvalidDeploymentInstanceTypeExceptionRes(parsedOutput, context);
        case "InvalidInstanceStatusException":
        case "com.amazonaws.codedeploy#InvalidInstanceStatusException":
            throw await de_InvalidInstanceStatusExceptionRes(parsedOutput, context);
        case "InvalidInstanceTypeException":
        case "com.amazonaws.codedeploy#InvalidInstanceTypeException":
            throw await de_InvalidInstanceTypeExceptionRes(parsedOutput, context);
        case "InvalidNextTokenException":
        case "com.amazonaws.codedeploy#InvalidNextTokenException":
            throw await de_InvalidNextTokenExceptionRes(parsedOutput, context);
        case "InvalidTargetFilterNameException":
        case "com.amazonaws.codedeploy#InvalidTargetFilterNameException":
            throw await de_InvalidTargetFilterNameExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListDeploymentsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListDeploymentsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListDeploymentsCommand = de_ListDeploymentsCommand;
const de_ListDeploymentsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ApplicationDoesNotExistException":
        case "com.amazonaws.codedeploy#ApplicationDoesNotExistException":
            throw await de_ApplicationDoesNotExistExceptionRes(parsedOutput, context);
        case "ApplicationNameRequiredException":
        case "com.amazonaws.codedeploy#ApplicationNameRequiredException":
            throw await de_ApplicationNameRequiredExceptionRes(parsedOutput, context);
        case "DeploymentGroupDoesNotExistException":
        case "com.amazonaws.codedeploy#DeploymentGroupDoesNotExistException":
            throw await de_DeploymentGroupDoesNotExistExceptionRes(parsedOutput, context);
        case "DeploymentGroupNameRequiredException":
        case "com.amazonaws.codedeploy#DeploymentGroupNameRequiredException":
            throw await de_DeploymentGroupNameRequiredExceptionRes(parsedOutput, context);
        case "InvalidApplicationNameException":
        case "com.amazonaws.codedeploy#InvalidApplicationNameException":
            throw await de_InvalidApplicationNameExceptionRes(parsedOutput, context);
        case "InvalidDeploymentGroupNameException":
        case "com.amazonaws.codedeploy#InvalidDeploymentGroupNameException":
            throw await de_InvalidDeploymentGroupNameExceptionRes(parsedOutput, context);
        case "InvalidDeploymentStatusException":
        case "com.amazonaws.codedeploy#InvalidDeploymentStatusException":
            throw await de_InvalidDeploymentStatusExceptionRes(parsedOutput, context);
        case "InvalidExternalIdException":
        case "com.amazonaws.codedeploy#InvalidExternalIdException":
            throw await de_InvalidExternalIdExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.codedeploy#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "InvalidNextTokenException":
        case "com.amazonaws.codedeploy#InvalidNextTokenException":
            throw await de_InvalidNextTokenExceptionRes(parsedOutput, context);
        case "InvalidTimeRangeException":
        case "com.amazonaws.codedeploy#InvalidTimeRangeException":
            throw await de_InvalidTimeRangeExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListDeploymentTargetsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListDeploymentTargetsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListDeploymentTargetsCommand = de_ListDeploymentTargetsCommand;
const de_ListDeploymentTargetsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeploymentDoesNotExistException":
        case "com.amazonaws.codedeploy#DeploymentDoesNotExistException":
            throw await de_DeploymentDoesNotExistExceptionRes(parsedOutput, context);
        case "DeploymentIdRequiredException":
        case "com.amazonaws.codedeploy#DeploymentIdRequiredException":
            throw await de_DeploymentIdRequiredExceptionRes(parsedOutput, context);
        case "DeploymentNotStartedException":
        case "com.amazonaws.codedeploy#DeploymentNotStartedException":
            throw await de_DeploymentNotStartedExceptionRes(parsedOutput, context);
        case "InvalidDeploymentIdException":
        case "com.amazonaws.codedeploy#InvalidDeploymentIdException":
            throw await de_InvalidDeploymentIdExceptionRes(parsedOutput, context);
        case "InvalidDeploymentInstanceTypeException":
        case "com.amazonaws.codedeploy#InvalidDeploymentInstanceTypeException":
            throw await de_InvalidDeploymentInstanceTypeExceptionRes(parsedOutput, context);
        case "InvalidInstanceStatusException":
        case "com.amazonaws.codedeploy#InvalidInstanceStatusException":
            throw await de_InvalidInstanceStatusExceptionRes(parsedOutput, context);
        case "InvalidInstanceTypeException":
        case "com.amazonaws.codedeploy#InvalidInstanceTypeException":
            throw await de_InvalidInstanceTypeExceptionRes(parsedOutput, context);
        case "InvalidNextTokenException":
        case "com.amazonaws.codedeploy#InvalidNextTokenException":
            throw await de_InvalidNextTokenExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListGitHubAccountTokenNamesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListGitHubAccountTokenNamesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListGitHubAccountTokenNamesCommand = de_ListGitHubAccountTokenNamesCommand;
const de_ListGitHubAccountTokenNamesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidNextTokenException":
        case "com.amazonaws.codedeploy#InvalidNextTokenException":
            throw await de_InvalidNextTokenExceptionRes(parsedOutput, context);
        case "OperationNotSupportedException":
        case "com.amazonaws.codedeploy#OperationNotSupportedException":
            throw await de_OperationNotSupportedExceptionRes(parsedOutput, context);
        case "ResourceValidationException":
        case "com.amazonaws.codedeploy#ResourceValidationException":
            throw await de_ResourceValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListOnPremisesInstancesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListOnPremisesInstancesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListOnPremisesInstancesCommand = de_ListOnPremisesInstancesCommand;
const de_ListOnPremisesInstancesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidNextTokenException":
        case "com.amazonaws.codedeploy#InvalidNextTokenException":
            throw await de_InvalidNextTokenExceptionRes(parsedOutput, context);
        case "InvalidRegistrationStatusException":
        case "com.amazonaws.codedeploy#InvalidRegistrationStatusException":
            throw await de_InvalidRegistrationStatusExceptionRes(parsedOutput, context);
        case "InvalidTagFilterException":
        case "com.amazonaws.codedeploy#InvalidTagFilterException":
            throw await de_InvalidTagFilterExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListTagsForResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListTagsForResourceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListTagsForResourceCommand = de_ListTagsForResourceCommand;
const de_ListTagsForResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ArnNotSupportedException":
        case "com.amazonaws.codedeploy#ArnNotSupportedException":
            throw await de_ArnNotSupportedExceptionRes(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.codedeploy#InvalidArnException":
            throw await de_InvalidArnExceptionRes(parsedOutput, context);
        case "ResourceArnRequiredException":
        case "com.amazonaws.codedeploy#ResourceArnRequiredException":
            throw await de_ResourceArnRequiredExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_PutLifecycleEventHookExecutionStatusCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_PutLifecycleEventHookExecutionStatusCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_PutLifecycleEventHookExecutionStatusCommand = de_PutLifecycleEventHookExecutionStatusCommand;
const de_PutLifecycleEventHookExecutionStatusCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeploymentDoesNotExistException":
        case "com.amazonaws.codedeploy#DeploymentDoesNotExistException":
            throw await de_DeploymentDoesNotExistExceptionRes(parsedOutput, context);
        case "DeploymentIdRequiredException":
        case "com.amazonaws.codedeploy#DeploymentIdRequiredException":
            throw await de_DeploymentIdRequiredExceptionRes(parsedOutput, context);
        case "InvalidDeploymentIdException":
        case "com.amazonaws.codedeploy#InvalidDeploymentIdException":
            throw await de_InvalidDeploymentIdExceptionRes(parsedOutput, context);
        case "InvalidLifecycleEventHookExecutionIdException":
        case "com.amazonaws.codedeploy#InvalidLifecycleEventHookExecutionIdException":
            throw await de_InvalidLifecycleEventHookExecutionIdExceptionRes(parsedOutput, context);
        case "InvalidLifecycleEventHookExecutionStatusException":
        case "com.amazonaws.codedeploy#InvalidLifecycleEventHookExecutionStatusException":
            throw await de_InvalidLifecycleEventHookExecutionStatusExceptionRes(parsedOutput, context);
        case "LifecycleEventAlreadyCompletedException":
        case "com.amazonaws.codedeploy#LifecycleEventAlreadyCompletedException":
            throw await de_LifecycleEventAlreadyCompletedExceptionRes(parsedOutput, context);
        case "UnsupportedActionForDeploymentTypeException":
        case "com.amazonaws.codedeploy#UnsupportedActionForDeploymentTypeException":
            throw await de_UnsupportedActionForDeploymentTypeExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_RegisterApplicationRevisionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_RegisterApplicationRevisionCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_RegisterApplicationRevisionCommand = de_RegisterApplicationRevisionCommand;
const de_RegisterApplicationRevisionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ApplicationDoesNotExistException":
        case "com.amazonaws.codedeploy#ApplicationDoesNotExistException":
            throw await de_ApplicationDoesNotExistExceptionRes(parsedOutput, context);
        case "ApplicationNameRequiredException":
        case "com.amazonaws.codedeploy#ApplicationNameRequiredException":
            throw await de_ApplicationNameRequiredExceptionRes(parsedOutput, context);
        case "DescriptionTooLongException":
        case "com.amazonaws.codedeploy#DescriptionTooLongException":
            throw await de_DescriptionTooLongExceptionRes(parsedOutput, context);
        case "InvalidApplicationNameException":
        case "com.amazonaws.codedeploy#InvalidApplicationNameException":
            throw await de_InvalidApplicationNameExceptionRes(parsedOutput, context);
        case "InvalidRevisionException":
        case "com.amazonaws.codedeploy#InvalidRevisionException":
            throw await de_InvalidRevisionExceptionRes(parsedOutput, context);
        case "RevisionRequiredException":
        case "com.amazonaws.codedeploy#RevisionRequiredException":
            throw await de_RevisionRequiredExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_RegisterOnPremisesInstanceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_RegisterOnPremisesInstanceCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_RegisterOnPremisesInstanceCommand = de_RegisterOnPremisesInstanceCommand;
const de_RegisterOnPremisesInstanceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "IamArnRequiredException":
        case "com.amazonaws.codedeploy#IamArnRequiredException":
            throw await de_IamArnRequiredExceptionRes(parsedOutput, context);
        case "IamSessionArnAlreadyRegisteredException":
        case "com.amazonaws.codedeploy#IamSessionArnAlreadyRegisteredException":
            throw await de_IamSessionArnAlreadyRegisteredExceptionRes(parsedOutput, context);
        case "IamUserArnAlreadyRegisteredException":
        case "com.amazonaws.codedeploy#IamUserArnAlreadyRegisteredException":
            throw await de_IamUserArnAlreadyRegisteredExceptionRes(parsedOutput, context);
        case "IamUserArnRequiredException":
        case "com.amazonaws.codedeploy#IamUserArnRequiredException":
            throw await de_IamUserArnRequiredExceptionRes(parsedOutput, context);
        case "InstanceNameAlreadyRegisteredException":
        case "com.amazonaws.codedeploy#InstanceNameAlreadyRegisteredException":
            throw await de_InstanceNameAlreadyRegisteredExceptionRes(parsedOutput, context);
        case "InstanceNameRequiredException":
        case "com.amazonaws.codedeploy#InstanceNameRequiredException":
            throw await de_InstanceNameRequiredExceptionRes(parsedOutput, context);
        case "InvalidIamSessionArnException":
        case "com.amazonaws.codedeploy#InvalidIamSessionArnException":
            throw await de_InvalidIamSessionArnExceptionRes(parsedOutput, context);
        case "InvalidIamUserArnException":
        case "com.amazonaws.codedeploy#InvalidIamUserArnException":
            throw await de_InvalidIamUserArnExceptionRes(parsedOutput, context);
        case "InvalidInstanceNameException":
        case "com.amazonaws.codedeploy#InvalidInstanceNameException":
            throw await de_InvalidInstanceNameExceptionRes(parsedOutput, context);
        case "MultipleIamArnsProvidedException":
        case "com.amazonaws.codedeploy#MultipleIamArnsProvidedException":
            throw await de_MultipleIamArnsProvidedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_RemoveTagsFromOnPremisesInstancesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_RemoveTagsFromOnPremisesInstancesCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_RemoveTagsFromOnPremisesInstancesCommand = de_RemoveTagsFromOnPremisesInstancesCommand;
const de_RemoveTagsFromOnPremisesInstancesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InstanceLimitExceededException":
        case "com.amazonaws.codedeploy#InstanceLimitExceededException":
            throw await de_InstanceLimitExceededExceptionRes(parsedOutput, context);
        case "InstanceNameRequiredException":
        case "com.amazonaws.codedeploy#InstanceNameRequiredException":
            throw await de_InstanceNameRequiredExceptionRes(parsedOutput, context);
        case "InstanceNotRegisteredException":
        case "com.amazonaws.codedeploy#InstanceNotRegisteredException":
            throw await de_InstanceNotRegisteredExceptionRes(parsedOutput, context);
        case "InvalidInstanceNameException":
        case "com.amazonaws.codedeploy#InvalidInstanceNameException":
            throw await de_InvalidInstanceNameExceptionRes(parsedOutput, context);
        case "InvalidTagException":
        case "com.amazonaws.codedeploy#InvalidTagException":
            throw await de_InvalidTagExceptionRes(parsedOutput, context);
        case "TagLimitExceededException":
        case "com.amazonaws.codedeploy#TagLimitExceededException":
            throw await de_TagLimitExceededExceptionRes(parsedOutput, context);
        case "TagRequiredException":
        case "com.amazonaws.codedeploy#TagRequiredException":
            throw await de_TagRequiredExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_SkipWaitTimeForInstanceTerminationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_SkipWaitTimeForInstanceTerminationCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_SkipWaitTimeForInstanceTerminationCommand = de_SkipWaitTimeForInstanceTerminationCommand;
const de_SkipWaitTimeForInstanceTerminationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeploymentAlreadyCompletedException":
        case "com.amazonaws.codedeploy#DeploymentAlreadyCompletedException":
            throw await de_DeploymentAlreadyCompletedExceptionRes(parsedOutput, context);
        case "DeploymentDoesNotExistException":
        case "com.amazonaws.codedeploy#DeploymentDoesNotExistException":
            throw await de_DeploymentDoesNotExistExceptionRes(parsedOutput, context);
        case "DeploymentIdRequiredException":
        case "com.amazonaws.codedeploy#DeploymentIdRequiredException":
            throw await de_DeploymentIdRequiredExceptionRes(parsedOutput, context);
        case "DeploymentNotStartedException":
        case "com.amazonaws.codedeploy#DeploymentNotStartedException":
            throw await de_DeploymentNotStartedExceptionRes(parsedOutput, context);
        case "InvalidDeploymentIdException":
        case "com.amazonaws.codedeploy#InvalidDeploymentIdException":
            throw await de_InvalidDeploymentIdExceptionRes(parsedOutput, context);
        case "UnsupportedActionForDeploymentTypeException":
        case "com.amazonaws.codedeploy#UnsupportedActionForDeploymentTypeException":
            throw await de_UnsupportedActionForDeploymentTypeExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_StopDeploymentCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_StopDeploymentCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_StopDeploymentCommand = de_StopDeploymentCommand;
const de_StopDeploymentCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeploymentAlreadyCompletedException":
        case "com.amazonaws.codedeploy#DeploymentAlreadyCompletedException":
            throw await de_DeploymentAlreadyCompletedExceptionRes(parsedOutput, context);
        case "DeploymentDoesNotExistException":
        case "com.amazonaws.codedeploy#DeploymentDoesNotExistException":
            throw await de_DeploymentDoesNotExistExceptionRes(parsedOutput, context);
        case "DeploymentGroupDoesNotExistException":
        case "com.amazonaws.codedeploy#DeploymentGroupDoesNotExistException":
            throw await de_DeploymentGroupDoesNotExistExceptionRes(parsedOutput, context);
        case "DeploymentIdRequiredException":
        case "com.amazonaws.codedeploy#DeploymentIdRequiredException":
            throw await de_DeploymentIdRequiredExceptionRes(parsedOutput, context);
        case "InvalidDeploymentIdException":
        case "com.amazonaws.codedeploy#InvalidDeploymentIdException":
            throw await de_InvalidDeploymentIdExceptionRes(parsedOutput, context);
        case "UnsupportedActionForDeploymentTypeException":
        case "com.amazonaws.codedeploy#UnsupportedActionForDeploymentTypeException":
            throw await de_UnsupportedActionForDeploymentTypeExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_TagResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_TagResourceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_TagResourceCommand = de_TagResourceCommand;
const de_TagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ApplicationDoesNotExistException":
        case "com.amazonaws.codedeploy#ApplicationDoesNotExistException":
            throw await de_ApplicationDoesNotExistExceptionRes(parsedOutput, context);
        case "ArnNotSupportedException":
        case "com.amazonaws.codedeploy#ArnNotSupportedException":
            throw await de_ArnNotSupportedExceptionRes(parsedOutput, context);
        case "DeploymentConfigDoesNotExistException":
        case "com.amazonaws.codedeploy#DeploymentConfigDoesNotExistException":
            throw await de_DeploymentConfigDoesNotExistExceptionRes(parsedOutput, context);
        case "DeploymentGroupDoesNotExistException":
        case "com.amazonaws.codedeploy#DeploymentGroupDoesNotExistException":
            throw await de_DeploymentGroupDoesNotExistExceptionRes(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.codedeploy#InvalidArnException":
            throw await de_InvalidArnExceptionRes(parsedOutput, context);
        case "InvalidTagsToAddException":
        case "com.amazonaws.codedeploy#InvalidTagsToAddException":
            throw await de_InvalidTagsToAddExceptionRes(parsedOutput, context);
        case "ResourceArnRequiredException":
        case "com.amazonaws.codedeploy#ResourceArnRequiredException":
            throw await de_ResourceArnRequiredExceptionRes(parsedOutput, context);
        case "TagRequiredException":
        case "com.amazonaws.codedeploy#TagRequiredException":
            throw await de_TagRequiredExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UntagResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UntagResourceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_UntagResourceCommand = de_UntagResourceCommand;
const de_UntagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ApplicationDoesNotExistException":
        case "com.amazonaws.codedeploy#ApplicationDoesNotExistException":
            throw await de_ApplicationDoesNotExistExceptionRes(parsedOutput, context);
        case "ArnNotSupportedException":
        case "com.amazonaws.codedeploy#ArnNotSupportedException":
            throw await de_ArnNotSupportedExceptionRes(parsedOutput, context);
        case "DeploymentConfigDoesNotExistException":
        case "com.amazonaws.codedeploy#DeploymentConfigDoesNotExistException":
            throw await de_DeploymentConfigDoesNotExistExceptionRes(parsedOutput, context);
        case "DeploymentGroupDoesNotExistException":
        case "com.amazonaws.codedeploy#DeploymentGroupDoesNotExistException":
            throw await de_DeploymentGroupDoesNotExistExceptionRes(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.codedeploy#InvalidArnException":
            throw await de_InvalidArnExceptionRes(parsedOutput, context);
        case "InvalidTagsToAddException":
        case "com.amazonaws.codedeploy#InvalidTagsToAddException":
            throw await de_InvalidTagsToAddExceptionRes(parsedOutput, context);
        case "ResourceArnRequiredException":
        case "com.amazonaws.codedeploy#ResourceArnRequiredException":
            throw await de_ResourceArnRequiredExceptionRes(parsedOutput, context);
        case "TagRequiredException":
        case "com.amazonaws.codedeploy#TagRequiredException":
            throw await de_TagRequiredExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateApplicationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateApplicationCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_UpdateApplicationCommand = de_UpdateApplicationCommand;
const de_UpdateApplicationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ApplicationAlreadyExistsException":
        case "com.amazonaws.codedeploy#ApplicationAlreadyExistsException":
            throw await de_ApplicationAlreadyExistsExceptionRes(parsedOutput, context);
        case "ApplicationDoesNotExistException":
        case "com.amazonaws.codedeploy#ApplicationDoesNotExistException":
            throw await de_ApplicationDoesNotExistExceptionRes(parsedOutput, context);
        case "ApplicationNameRequiredException":
        case "com.amazonaws.codedeploy#ApplicationNameRequiredException":
            throw await de_ApplicationNameRequiredExceptionRes(parsedOutput, context);
        case "InvalidApplicationNameException":
        case "com.amazonaws.codedeploy#InvalidApplicationNameException":
            throw await de_InvalidApplicationNameExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateDeploymentGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateDeploymentGroupCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_UpdateDeploymentGroupCommand = de_UpdateDeploymentGroupCommand;
const de_UpdateDeploymentGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AlarmsLimitExceededException":
        case "com.amazonaws.codedeploy#AlarmsLimitExceededException":
            throw await de_AlarmsLimitExceededExceptionRes(parsedOutput, context);
        case "ApplicationDoesNotExistException":
        case "com.amazonaws.codedeploy#ApplicationDoesNotExistException":
            throw await de_ApplicationDoesNotExistExceptionRes(parsedOutput, context);
        case "ApplicationNameRequiredException":
        case "com.amazonaws.codedeploy#ApplicationNameRequiredException":
            throw await de_ApplicationNameRequiredExceptionRes(parsedOutput, context);
        case "DeploymentConfigDoesNotExistException":
        case "com.amazonaws.codedeploy#DeploymentConfigDoesNotExistException":
            throw await de_DeploymentConfigDoesNotExistExceptionRes(parsedOutput, context);
        case "DeploymentGroupAlreadyExistsException":
        case "com.amazonaws.codedeploy#DeploymentGroupAlreadyExistsException":
            throw await de_DeploymentGroupAlreadyExistsExceptionRes(parsedOutput, context);
        case "DeploymentGroupDoesNotExistException":
        case "com.amazonaws.codedeploy#DeploymentGroupDoesNotExistException":
            throw await de_DeploymentGroupDoesNotExistExceptionRes(parsedOutput, context);
        case "DeploymentGroupNameRequiredException":
        case "com.amazonaws.codedeploy#DeploymentGroupNameRequiredException":
            throw await de_DeploymentGroupNameRequiredExceptionRes(parsedOutput, context);
        case "ECSServiceMappingLimitExceededException":
        case "com.amazonaws.codedeploy#ECSServiceMappingLimitExceededException":
            throw await de_ECSServiceMappingLimitExceededExceptionRes(parsedOutput, context);
        case "InvalidAlarmConfigException":
        case "com.amazonaws.codedeploy#InvalidAlarmConfigException":
            throw await de_InvalidAlarmConfigExceptionRes(parsedOutput, context);
        case "InvalidApplicationNameException":
        case "com.amazonaws.codedeploy#InvalidApplicationNameException":
            throw await de_InvalidApplicationNameExceptionRes(parsedOutput, context);
        case "InvalidAutoRollbackConfigException":
        case "com.amazonaws.codedeploy#InvalidAutoRollbackConfigException":
            throw await de_InvalidAutoRollbackConfigExceptionRes(parsedOutput, context);
        case "InvalidAutoScalingGroupException":
        case "com.amazonaws.codedeploy#InvalidAutoScalingGroupException":
            throw await de_InvalidAutoScalingGroupExceptionRes(parsedOutput, context);
        case "InvalidBlueGreenDeploymentConfigurationException":
        case "com.amazonaws.codedeploy#InvalidBlueGreenDeploymentConfigurationException":
            throw await de_InvalidBlueGreenDeploymentConfigurationExceptionRes(parsedOutput, context);
        case "InvalidDeploymentConfigNameException":
        case "com.amazonaws.codedeploy#InvalidDeploymentConfigNameException":
            throw await de_InvalidDeploymentConfigNameExceptionRes(parsedOutput, context);
        case "InvalidDeploymentGroupNameException":
        case "com.amazonaws.codedeploy#InvalidDeploymentGroupNameException":
            throw await de_InvalidDeploymentGroupNameExceptionRes(parsedOutput, context);
        case "InvalidDeploymentStyleException":
        case "com.amazonaws.codedeploy#InvalidDeploymentStyleException":
            throw await de_InvalidDeploymentStyleExceptionRes(parsedOutput, context);
        case "InvalidEC2TagCombinationException":
        case "com.amazonaws.codedeploy#InvalidEC2TagCombinationException":
            throw await de_InvalidEC2TagCombinationExceptionRes(parsedOutput, context);
        case "InvalidEC2TagException":
        case "com.amazonaws.codedeploy#InvalidEC2TagException":
            throw await de_InvalidEC2TagExceptionRes(parsedOutput, context);
        case "InvalidECSServiceException":
        case "com.amazonaws.codedeploy#InvalidECSServiceException":
            throw await de_InvalidECSServiceExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.codedeploy#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "InvalidLoadBalancerInfoException":
        case "com.amazonaws.codedeploy#InvalidLoadBalancerInfoException":
            throw await de_InvalidLoadBalancerInfoExceptionRes(parsedOutput, context);
        case "InvalidOnPremisesTagCombinationException":
        case "com.amazonaws.codedeploy#InvalidOnPremisesTagCombinationException":
            throw await de_InvalidOnPremisesTagCombinationExceptionRes(parsedOutput, context);
        case "InvalidRoleException":
        case "com.amazonaws.codedeploy#InvalidRoleException":
            throw await de_InvalidRoleExceptionRes(parsedOutput, context);
        case "InvalidTagException":
        case "com.amazonaws.codedeploy#InvalidTagException":
            throw await de_InvalidTagExceptionRes(parsedOutput, context);
        case "InvalidTargetGroupPairException":
        case "com.amazonaws.codedeploy#InvalidTargetGroupPairException":
            throw await de_InvalidTargetGroupPairExceptionRes(parsedOutput, context);
        case "InvalidTrafficRoutingConfigurationException":
        case "com.amazonaws.codedeploy#InvalidTrafficRoutingConfigurationException":
            throw await de_InvalidTrafficRoutingConfigurationExceptionRes(parsedOutput, context);
        case "InvalidTriggerConfigException":
        case "com.amazonaws.codedeploy#InvalidTriggerConfigException":
            throw await de_InvalidTriggerConfigExceptionRes(parsedOutput, context);
        case "LifecycleHookLimitExceededException":
        case "com.amazonaws.codedeploy#LifecycleHookLimitExceededException":
            throw await de_LifecycleHookLimitExceededExceptionRes(parsedOutput, context);
        case "TagSetListLimitExceededException":
        case "com.amazonaws.codedeploy#TagSetListLimitExceededException":
            throw await de_TagSetListLimitExceededExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.codedeploy#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "TriggerTargetsLimitExceededException":
        case "com.amazonaws.codedeploy#TriggerTargetsLimitExceededException":
            throw await de_TriggerTargetsLimitExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_AlarmsLimitExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.AlarmsLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ApplicationAlreadyExistsExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.ApplicationAlreadyExistsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ApplicationDoesNotExistExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.ApplicationDoesNotExistException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ApplicationLimitExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.ApplicationLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ApplicationNameRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.ApplicationNameRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ArnNotSupportedExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.ArnNotSupportedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_BatchLimitExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.BatchLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_BucketNameFilterRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.BucketNameFilterRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_DeploymentAlreadyCompletedExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.DeploymentAlreadyCompletedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_DeploymentConfigAlreadyExistsExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.DeploymentConfigAlreadyExistsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_DeploymentConfigDoesNotExistExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.DeploymentConfigDoesNotExistException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_DeploymentConfigInUseExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.DeploymentConfigInUseException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_DeploymentConfigLimitExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.DeploymentConfigLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_DeploymentConfigNameRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.DeploymentConfigNameRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_DeploymentDoesNotExistExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.DeploymentDoesNotExistException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_DeploymentGroupAlreadyExistsExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.DeploymentGroupAlreadyExistsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_DeploymentGroupDoesNotExistExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.DeploymentGroupDoesNotExistException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_DeploymentGroupLimitExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.DeploymentGroupLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_DeploymentGroupNameRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.DeploymentGroupNameRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_DeploymentIdRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.DeploymentIdRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_DeploymentIsNotInReadyStateExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.DeploymentIsNotInReadyStateException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_DeploymentLimitExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.DeploymentLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_DeploymentNotStartedExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.DeploymentNotStartedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_DeploymentTargetDoesNotExistExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.DeploymentTargetDoesNotExistException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_DeploymentTargetIdRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.DeploymentTargetIdRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_DeploymentTargetListSizeExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.DeploymentTargetListSizeExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_DescriptionTooLongExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.DescriptionTooLongException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ECSServiceMappingLimitExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.ECSServiceMappingLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_GitHubAccountTokenDoesNotExistExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.GitHubAccountTokenDoesNotExistException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_GitHubAccountTokenNameRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.GitHubAccountTokenNameRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_IamArnRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.IamArnRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_IamSessionArnAlreadyRegisteredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.IamSessionArnAlreadyRegisteredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_IamUserArnAlreadyRegisteredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.IamUserArnAlreadyRegisteredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_IamUserArnRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.IamUserArnRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InstanceDoesNotExistExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InstanceDoesNotExistException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InstanceIdRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InstanceIdRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InstanceLimitExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InstanceLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InstanceNameAlreadyRegisteredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InstanceNameAlreadyRegisteredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InstanceNameRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InstanceNameRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InstanceNotRegisteredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InstanceNotRegisteredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidAlarmConfigExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidAlarmConfigException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidApplicationNameExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidApplicationNameException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidArnExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidArnException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidAutoRollbackConfigExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidAutoRollbackConfigException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidAutoScalingGroupExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidAutoScalingGroupException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidBlueGreenDeploymentConfigurationExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidBlueGreenDeploymentConfigurationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidBucketNameFilterExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidBucketNameFilterException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidComputePlatformExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidComputePlatformException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidDeployedStateFilterExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidDeployedStateFilterException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidDeploymentConfigNameExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidDeploymentConfigNameException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidDeploymentGroupNameExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidDeploymentGroupNameException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidDeploymentIdExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidDeploymentIdException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidDeploymentInstanceTypeExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidDeploymentInstanceTypeException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidDeploymentStatusExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidDeploymentStatusException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidDeploymentStyleExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidDeploymentStyleException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidDeploymentTargetIdExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidDeploymentTargetIdException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidDeploymentWaitTypeExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidDeploymentWaitTypeException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidEC2TagCombinationExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidEC2TagCombinationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidEC2TagExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidEC2TagException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidECSServiceExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidECSServiceException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidExternalIdExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidExternalIdException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidFileExistsBehaviorExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidFileExistsBehaviorException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidGitHubAccountTokenExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidGitHubAccountTokenException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidGitHubAccountTokenNameExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidGitHubAccountTokenNameException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidIamSessionArnExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidIamSessionArnException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidIamUserArnExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidIamUserArnException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidIgnoreApplicationStopFailuresValueExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidIgnoreApplicationStopFailuresValueException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidInputExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidInputException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidInstanceNameExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidInstanceNameException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidInstanceStatusExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidInstanceStatusException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidInstanceTypeExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidInstanceTypeException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidKeyPrefixFilterExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidKeyPrefixFilterException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidLifecycleEventHookExecutionIdExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidLifecycleEventHookExecutionIdException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidLifecycleEventHookExecutionStatusExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidLifecycleEventHookExecutionStatusException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidLoadBalancerInfoExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidLoadBalancerInfoException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidMinimumHealthyHostValueExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidMinimumHealthyHostValueException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidNextTokenExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidNextTokenException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidOnPremisesTagCombinationExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidOnPremisesTagCombinationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidOperationExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidOperationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidRegistrationStatusExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidRegistrationStatusException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidRevisionExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidRevisionException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidRoleExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidRoleException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidSortByExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidSortByException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidSortOrderExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidSortOrderException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidTagExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidTagException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidTagFilterExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidTagFilterException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidTagsToAddExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidTagsToAddException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidTargetFilterNameExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidTargetFilterNameException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidTargetGroupPairExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidTargetGroupPairException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidTargetInstancesExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidTargetInstancesException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidTimeRangeExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidTimeRangeException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidTrafficRoutingConfigurationExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidTrafficRoutingConfigurationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidTriggerConfigExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidTriggerConfigException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidUpdateOutdatedInstancesOnlyValueExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidUpdateOutdatedInstancesOnlyValueException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_LifecycleEventAlreadyCompletedExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.LifecycleEventAlreadyCompletedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_LifecycleHookLimitExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.LifecycleHookLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_MultipleIamArnsProvidedExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.MultipleIamArnsProvidedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_OperationNotSupportedExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.OperationNotSupportedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ResourceArnRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.ResourceArnRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ResourceValidationExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.ResourceValidationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_RevisionDoesNotExistExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.RevisionDoesNotExistException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_RevisionRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.RevisionRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_RoleRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.RoleRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_TagLimitExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.TagLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_TagRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.TagRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_TagSetListLimitExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.TagSetListLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ThrottlingExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.ThrottlingException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_TriggerTargetsLimitExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.TriggerTargetsLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_UnsupportedActionForDeploymentTypeExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.UnsupportedActionForDeploymentTypeException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const se_ListDeploymentsInput = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        applicationName: [],
        createTimeRange: (_) => se_TimeRange(_, context),
        deploymentGroupName: [],
        externalId: [],
        includeOnlyStatuses: smithy_client_1._json,
        nextToken: [],
    });
};
const se_TimeRange = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        end: (_) => Math.round(_.getTime() / 1000),
        start: (_) => Math.round(_.getTime() / 1000),
    });
};
const de_ApplicationInfo = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        applicationId: smithy_client_1.expectString,
        applicationName: smithy_client_1.expectString,
        computePlatform: smithy_client_1.expectString,
        createTime: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        gitHubAccountName: smithy_client_1.expectString,
        linkedToGitHub: smithy_client_1.expectBoolean,
    });
};
const de_ApplicationsInfoList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ApplicationInfo(entry, context);
    });
    return retVal;
};
const de_BatchGetApplicationRevisionsOutput = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        applicationName: smithy_client_1.expectString,
        errorMessage: smithy_client_1.expectString,
        revisions: (_) => de_RevisionInfoList(_, context),
    });
};
const de_BatchGetApplicationsOutput = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        applicationsInfo: (_) => de_ApplicationsInfoList(_, context),
    });
};
const de_BatchGetDeploymentGroupsOutput = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        deploymentGroupsInfo: (_) => de_DeploymentGroupInfoList(_, context),
        errorMessage: smithy_client_1.expectString,
    });
};
const de_BatchGetDeploymentInstancesOutput = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        errorMessage: smithy_client_1.expectString,
        instancesSummary: (_) => de_InstanceSummaryList(_, context),
    });
};
const de_BatchGetDeploymentsOutput = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        deploymentsInfo: (_) => de_DeploymentsInfoList(_, context),
    });
};
const de_BatchGetDeploymentTargetsOutput = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        deploymentTargets: (_) => de_DeploymentTargetList(_, context),
    });
};
const de_BatchGetOnPremisesInstancesOutput = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        instanceInfos: (_) => de_InstanceInfoList(_, context),
    });
};
const de_CloudFormationTarget = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        deploymentId: smithy_client_1.expectString,
        lastUpdatedAt: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        lifecycleEvents: (_) => de_LifecycleEventList(_, context),
        resourceType: smithy_client_1.expectString,
        status: smithy_client_1.expectString,
        targetId: smithy_client_1.expectString,
        targetVersionWeight: smithy_client_1.limitedParseDouble,
    });
};
const de_DeploymentConfigInfo = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        computePlatform: smithy_client_1.expectString,
        createTime: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        deploymentConfigId: smithy_client_1.expectString,
        deploymentConfigName: smithy_client_1.expectString,
        minimumHealthyHosts: smithy_client_1._json,
        trafficRoutingConfig: smithy_client_1._json,
    });
};
const de_DeploymentGroupInfo = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        alarmConfiguration: smithy_client_1._json,
        applicationName: smithy_client_1.expectString,
        autoRollbackConfiguration: smithy_client_1._json,
        autoScalingGroups: smithy_client_1._json,
        blueGreenDeploymentConfiguration: smithy_client_1._json,
        computePlatform: smithy_client_1.expectString,
        deploymentConfigName: smithy_client_1.expectString,
        deploymentGroupId: smithy_client_1.expectString,
        deploymentGroupName: smithy_client_1.expectString,
        deploymentStyle: smithy_client_1._json,
        ec2TagFilters: smithy_client_1._json,
        ec2TagSet: smithy_client_1._json,
        ecsServices: smithy_client_1._json,
        lastAttemptedDeployment: (_) => de_LastDeploymentInfo(_, context),
        lastSuccessfulDeployment: (_) => de_LastDeploymentInfo(_, context),
        loadBalancerInfo: smithy_client_1._json,
        onPremisesInstanceTagFilters: smithy_client_1._json,
        onPremisesTagSet: smithy_client_1._json,
        outdatedInstancesStrategy: smithy_client_1.expectString,
        serviceRoleArn: smithy_client_1.expectString,
        targetRevision: smithy_client_1._json,
        triggerConfigurations: smithy_client_1._json,
    });
};
const de_DeploymentGroupInfoList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DeploymentGroupInfo(entry, context);
    });
    return retVal;
};
const de_DeploymentInfo = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        additionalDeploymentStatusInfo: smithy_client_1.expectString,
        applicationName: smithy_client_1.expectString,
        autoRollbackConfiguration: smithy_client_1._json,
        blueGreenDeploymentConfiguration: smithy_client_1._json,
        completeTime: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        computePlatform: smithy_client_1.expectString,
        createTime: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        creator: smithy_client_1.expectString,
        deploymentConfigName: smithy_client_1.expectString,
        deploymentGroupName: smithy_client_1.expectString,
        deploymentId: smithy_client_1.expectString,
        deploymentOverview: smithy_client_1._json,
        deploymentStatusMessages: smithy_client_1._json,
        deploymentStyle: smithy_client_1._json,
        description: smithy_client_1.expectString,
        errorInformation: smithy_client_1._json,
        externalId: smithy_client_1.expectString,
        fileExistsBehavior: smithy_client_1.expectString,
        ignoreApplicationStopFailures: smithy_client_1.expectBoolean,
        instanceTerminationWaitTimeStarted: smithy_client_1.expectBoolean,
        loadBalancerInfo: smithy_client_1._json,
        overrideAlarmConfiguration: smithy_client_1._json,
        previousRevision: smithy_client_1._json,
        relatedDeployments: smithy_client_1._json,
        revision: smithy_client_1._json,
        rollbackInfo: smithy_client_1._json,
        startTime: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        status: smithy_client_1.expectString,
        targetInstances: smithy_client_1._json,
        updateOutdatedInstancesOnly: smithy_client_1.expectBoolean,
    });
};
const de_DeploymentsInfoList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DeploymentInfo(entry, context);
    });
    return retVal;
};
const de_DeploymentTarget = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        cloudFormationTarget: (_) => de_CloudFormationTarget(_, context),
        deploymentTargetType: smithy_client_1.expectString,
        ecsTarget: (_) => de_ECSTarget(_, context),
        instanceTarget: (_) => de_InstanceTarget(_, context),
        lambdaTarget: (_) => de_LambdaTarget(_, context),
    });
};
const de_DeploymentTargetList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DeploymentTarget(entry, context);
    });
    return retVal;
};
const de_ECSTarget = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        deploymentId: smithy_client_1.expectString,
        lastUpdatedAt: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        lifecycleEvents: (_) => de_LifecycleEventList(_, context),
        status: smithy_client_1.expectString,
        targetArn: smithy_client_1.expectString,
        targetId: smithy_client_1.expectString,
        taskSetsInfo: (_) => de_ECSTaskSetList(_, context),
    });
};
const de_ECSTaskSet = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        desiredCount: smithy_client_1.expectLong,
        identifer: smithy_client_1.expectString,
        pendingCount: smithy_client_1.expectLong,
        runningCount: smithy_client_1.expectLong,
        status: smithy_client_1.expectString,
        targetGroup: smithy_client_1._json,
        taskSetLabel: smithy_client_1.expectString,
        trafficWeight: smithy_client_1.limitedParseDouble,
    });
};
const de_ECSTaskSetList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ECSTaskSet(entry, context);
    });
    return retVal;
};
const de_GenericRevisionInfo = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        deploymentGroups: smithy_client_1._json,
        description: smithy_client_1.expectString,
        firstUsedTime: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        lastUsedTime: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        registerTime: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
    });
};
const de_GetApplicationOutput = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        application: (_) => de_ApplicationInfo(_, context),
    });
};
const de_GetApplicationRevisionOutput = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        applicationName: smithy_client_1.expectString,
        revision: smithy_client_1._json,
        revisionInfo: (_) => de_GenericRevisionInfo(_, context),
    });
};
const de_GetDeploymentConfigOutput = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        deploymentConfigInfo: (_) => de_DeploymentConfigInfo(_, context),
    });
};
const de_GetDeploymentGroupOutput = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        deploymentGroupInfo: (_) => de_DeploymentGroupInfo(_, context),
    });
};
const de_GetDeploymentInstanceOutput = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        instanceSummary: (_) => de_InstanceSummary(_, context),
    });
};
const de_GetDeploymentOutput = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        deploymentInfo: (_) => de_DeploymentInfo(_, context),
    });
};
const de_GetDeploymentTargetOutput = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        deploymentTarget: (_) => de_DeploymentTarget(_, context),
    });
};
const de_GetOnPremisesInstanceOutput = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        instanceInfo: (_) => de_InstanceInfo(_, context),
    });
};
const de_InstanceInfo = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        deregisterTime: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        iamSessionArn: smithy_client_1.expectString,
        iamUserArn: smithy_client_1.expectString,
        instanceArn: smithy_client_1.expectString,
        instanceName: smithy_client_1.expectString,
        registerTime: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        tags: smithy_client_1._json,
    });
};
const de_InstanceInfoList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_InstanceInfo(entry, context);
    });
    return retVal;
};
const de_InstanceSummary = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        deploymentId: smithy_client_1.expectString,
        instanceId: smithy_client_1.expectString,
        instanceType: smithy_client_1.expectString,
        lastUpdatedAt: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        lifecycleEvents: (_) => de_LifecycleEventList(_, context),
        status: smithy_client_1.expectString,
    });
};
const de_InstanceSummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_InstanceSummary(entry, context);
    });
    return retVal;
};
const de_InstanceTarget = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        deploymentId: smithy_client_1.expectString,
        instanceLabel: smithy_client_1.expectString,
        lastUpdatedAt: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        lifecycleEvents: (_) => de_LifecycleEventList(_, context),
        status: smithy_client_1.expectString,
        targetArn: smithy_client_1.expectString,
        targetId: smithy_client_1.expectString,
    });
};
const de_LambdaFunctionInfo = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        currentVersion: smithy_client_1.expectString,
        functionAlias: smithy_client_1.expectString,
        functionName: smithy_client_1.expectString,
        targetVersion: smithy_client_1.expectString,
        targetVersionWeight: smithy_client_1.limitedParseDouble,
    });
};
const de_LambdaTarget = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        deploymentId: smithy_client_1.expectString,
        lambdaFunctionInfo: (_) => de_LambdaFunctionInfo(_, context),
        lastUpdatedAt: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        lifecycleEvents: (_) => de_LifecycleEventList(_, context),
        status: smithy_client_1.expectString,
        targetArn: smithy_client_1.expectString,
        targetId: smithy_client_1.expectString,
    });
};
const de_LastDeploymentInfo = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        createTime: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        deploymentId: smithy_client_1.expectString,
        endTime: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        status: smithy_client_1.expectString,
    });
};
const de_LifecycleEvent = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        diagnostics: smithy_client_1._json,
        endTime: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        lifecycleEventName: smithy_client_1.expectString,
        startTime: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        status: smithy_client_1.expectString,
    });
};
const de_LifecycleEventList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LifecycleEvent(entry, context);
    });
    return retVal;
};
const de_RevisionInfo = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        genericRevisionInfo: (_) => de_GenericRevisionInfo(_, context),
        revisionLocation: smithy_client_1._json,
    });
};
const de_RevisionInfoList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RevisionInfo(entry, context);
    });
    return retVal;
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => (0, smithy_client_1.collectBody)(streamBody, context).then((body) => context.utf8Encoder(body));
const throwDefaultError = (0, smithy_client_1.withBaseException)(CodeDeployServiceException_1.CodeDeployServiceException);
const buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const contents = {
        protocol,
        hostname,
        port,
        method: "POST",
        path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
        headers,
    };
    if (resolvedHostname !== undefined) {
        contents.hostname = resolvedHostname;
    }
    if (body !== undefined) {
        contents.body = body;
    }
    return new protocol_http_1.HttpRequest(contents);
};
function sharedHeaders(operation) {
    return {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": `CodeDeploy_20141006.${operation}`,
    };
}
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        return JSON.parse(encoded);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
};
const loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
            cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
    }
};
